{"/home/travis/build/npmtest/node-npmtest-q-io/test.js":"/* istanbul instrument in package npmtest_q_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-q-io/lib.npmtest_q_io.js":"/* istanbul instrument in package npmtest_q_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_q_io = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_q_io = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-q-io/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-q-io && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_q_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_q_io\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_q_io.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_q_io.rollup.js'] =\n            local.assetsDict['/assets.npmtest_q_io.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_q_io.__dirname +\n                    '/lib.npmtest_q_io.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/buffer-stream.js":"\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\n\nmodule.exports = BufferStream;\nfunction BufferStream(chunks, charset) {\n    if (!(this instanceof BufferStream)) {\n        return new BufferStream(chunks, charset);\n    }\n    if (!chunks) {\n        chunks = [];\n    } else if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n    }\n    this._charset = charset;\n    this._chunks = chunks;\n    this._close = Q.defer();\n    this.closed = this._close.promise;\n}\n\nBufferStream.prototype.forEach = function (write, thisp) {\n    var self = this;\n    var chunks = self._chunks;\n    return Q.fcall(function () {\n        chunks.splice(0, chunks.length).forEach(write, thisp);\n    });\n};\n\nBufferStream.prototype.read = function () {\n    var result;\n    result = Reader.join(this._chunks);\n    if (this._charset) {\n        result = result.toString(this._charset);\n    }\n    return Q.resolve(result);\n};\n\nBufferStream.prototype.write = function (chunk) {\n    if (this._charset) {\n        chunk = new Buffer(String(chunk), this._charset);\n    } else {\n        if (!(chunk instanceof Buffer)) {\n            throw new Error(\"Can't write strings to buffer stream without a charset: \" + chunk);\n        }\n    }\n    this._chunks.push(chunk);\n    return Q.resolve();\n};\n\nBufferStream.prototype.close = function () {\n    this._close.resolve();\n    return Q.resolve();\n};\n\nBufferStream.prototype.destroy = function () {\n    this._close.resolve();\n    return Q.resolve();\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/reader.js":"\nvar Q = require(\"q\");\n\n/**\n * Wraps a Node readable stream, providing an API similar\n * to a Narwhal synchronous `io` stream except returning\n * Q promises for long latency operations.\n * @param stream any Node readable stream\n * @returns {Promise * Reader} a promise for\n * the text stream reader.\n * @constructor\n */\nmodule.exports = Reader;\nfunction Reader(_stream, charset) {\n    var self = Object.create(Reader.prototype);\n\n    if (charset && _stream.setEncoding) // TODO complain about inconsistency\n        _stream.setEncoding(charset);\n\n    var begin = Q.defer();\n    var end = Q.defer();\n\n    _stream.on(\"error\", function (reason) {\n        begin.reject(reason);\n    });\n\n    var chunks = [];\n    var receiver;\n\n    _stream.on(\"end\", function () {\n        begin.resolve(self);\n        end.resolve()\n    });\n\n    _stream.on(\"data\", function (chunk) {\n        begin.resolve(self);\n        if (receiver) {\n            receiver(chunk);\n        } else {\n            chunks.push(chunk);\n        }\n    });\n\n    function slurp() {\n        var result;\n        if (charset) {\n            result = chunks.join(\"\");\n        } else {\n            result = self.constructor.join(chunks);\n        }\n        chunks.splice(0, chunks.length);\n        return result;\n    }\n\n    /***\n     * Reads all of the remaining data from the stream.\n     * @returns {Promise * String} a promise for a String\n     * containing the entirety the remaining stream.\n     */\n    self.read = function () {\n        receiver = undefined;\n        var deferred = Q.defer();\n        Q.done(end.promise, function () {\n            deferred.resolve(slurp());\n        });\n        return deferred.promise;\n    };\n\n    /***\n     * Reads and writes all of the remaining data from the\n     * stream in chunks.\n     * @param {Function(Promise * String)} write a function\n     * to be called on each chunk of input from this stream.\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the input is depleted.\n     */\n    self.forEach = function (write) {\n        if (chunks && chunks.length)\n            write(slurp());\n        receiver = write;\n        return Q.when(end.promise, function () {\n            receiver = undefined;\n        });\n    };\n\n    self.close = function () {\n        _stream.destroy();\n    };\n\n    self.node = _stream;\n\n    return begin.promise;\n}\n\n/*\n    Reads an entire forEachable stream of buffers and returns a single buffer.\n*/\nReader.read = read;\nfunction read(stream, charset) {\n    var chunks = [];\n    stream.forEach(function (chunk) {\n        chunks.push(chunk);\n    });\n    if (charset) {\n        return chunks.join(\"\");\n    } else {\n        return join(chunks);\n    }\n}\n\nReader.join = join;\nfunction join(buffers) {\n    var length = 0;\n    var at;\n    var i;\n    var ii = buffers.length;\n    var buffer;\n    var result;\n    for (i = 0; i < ii; i++) {\n        buffer = buffers[i];\n        length += buffer.length;\n    }\n    result = new Buffer(length);\n    at = 0;\n    for (i = 0; i < ii; i++) {\n        buffer = buffers[i];\n        buffer.copy(result, at, 0);\n        at += buffer.length;\n    }\n    buffers.splice(0, ii, result);\n    return result;\n}\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/deprecate.js":"/**\n * @module deprecate\n */\n\n/**\n * Prints out a deprecation warning to the console.warn with the format:\n * `name` is deprecated, use `alternative` instead.\n * It can also print out a stack trace with the line numbers.\n * @param {String} name - Name of the thing that is deprecated.\n * @param {String} alternative - Name of alternative that should be used instead.\n * @param {Number} [stackTraceLimit] - depth of the stack trace to print out. Set to falsy value to disable stack.\n */\nexports.deprecationWarning = function deprecationWarning(name, alternative, stackTraceLimit) {\n    if (stackTraceLimit) {\n        var depth = Error.stackTraceLimit;\n        Error.stackTraceLimit = stackTraceLimit;\n    }\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n        var stack = (stackTraceLimit ? new Error(\"\").stack : \"\") ;\n        if(alternative) {\n            console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", stack);\n        } else {\n            //name is a complete message\n            console.warn(name, stack);\n        }\n    }\n    if (stackTraceLimit) {\n        Error.stackTraceLimit = depth;\n    }\n}\n\n/**\n * Provides a function that can replace a method that has been deprecated.\n * Prints out a deprecation warning to the console.warn with the format:\n * `name` is deprecated, use `alternative` instead.\n * It will also print out a stack trace with the line numbers.\n * @param {Object} scope - The object that will be used as the `this` when the `deprecatedFunction` is applied.\n * @param {Function} deprecatedFunction - The function object that is deprecated.\n * @param {String} name - Name of the method that is deprecated.\n * @param {String} alternative - Name of alternative method that should be used instead.\n * @returns {Function} deprecationWrapper\n */\nexports.deprecateMethod = function deprecate(scope, deprecatedFunction, name, alternative) {\n    var deprecationWrapper = function () {\n        // stackTraceLimit = 3 // deprecationWarning + deprecate + caller of the deprecated method\n        deprecationWarning(name, alternative, 3);\n        return deprecatedFunction.apply(scope ? scope : this, arguments);\n    };\n    deprecationWrapper.deprecatedFunction = deprecatedFunction;\n    return deprecationWrapper;\n}\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/fs-boot.js":"(function (exports) {\n\n// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License\n// -- tlrobinson Tom Robinson TODO\n\n/**\n * Pure JavaScript implementations of file system path\n * manipulation.\n */\n\n// NOTE: this file may be used is the engine bootstrapping\n// process, so any \"requires\" must be accounted for in\n// narwhal.js\n\n/*whatsupdoc*/\n/*markup markdown*/\n\nvar regExpEscape = function (str) {\n    return str.replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\");\n};\n\nvar path = require(\"path\");\n\n/**\n * @name ROOT\n * * `/` on Unix\n * * `\\` on Windows\n */\n\n/**\n * @name SEPARATOR\n * * `/` on Unix\n * * `\\` on Windows\n */\n\n/**\n * @name ALT_SEPARATOR\n * * undefined on Unix\n * * `/` on Windows\n */\n\nexports.ROOT = exports.SEPARATOR = path.sep || (process.platform === \"win32\" ? \"\\\\\": \"/\");\nif (path.sep === \"\\\\\") {\n    exports.ALT_SEPARATOR = \"/\";\n} else {\n    exports.ALT_SEPARATOR = undefined;\n}\n\n// we need to make sure the separator regex is always in sync with the separators.\n// this caches the generated regex and rebuild if either separator changes.\nvar separatorCached, altSeparatorCached, separatorReCached;\n/**\n * @function\n */\nexports.SEPARATORS_RE = function () {\n    if (\n        separatorCached !== exports.SEPARATOR ||\n        altSeparatorCached !== exports.ALT_SEPARATOR\n    ) {\n        separatorCached = exports.SEPARATOR;\n        altSeparatorCached = exports.ALT_SEPARATOR;\n        separatorReCached = new RegExp(\"[\" +\n            (separatorCached || \"\").replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\") +\n            (altSeparatorCached || \"\").replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\") +\n        \"]\", \"g\");\n    }\n    return separatorReCached;\n}\n\n/**\n * separates a path into components.  If the path is\n * absolute, the first path component is the root of the\n * file system, indicated by an empty string on Unix, and a\n * drive letter followed by a colon on Windows.\n * @returns {Array * String}\n */\nexports.split = function (path) {\n    var parts;\n    try {\n        parts = String(path).split(exports.SEPARATORS_RE());\n    } catch (exception) {\n        throw new Error(\"Cannot split \" + (typeof path) + \", \" + JSON.stringify(path));\n    }\n    // this special case helps isAbsolute\n    // distinguish an empty path from an absolute path\n    // \"\" -> [] NOT [\"\"]\n    if (parts.length === 1 && parts[0] === \"\")\n        return [];\n    // \"a\" -> [\"a\"]\n    // \"/a\" -> [\"\", \"a\"]\n    return parts;\n};\n\n/**\n * Takes file system paths as variadic arguments and treats\n * each as a file or directory path and returns the path\n * arrived by traversing into the those paths.  All\n * arguments except for the last must be paths to\n * directories for the result to be meaningful.\n * @returns {String} path\n */\nexports.join = function () {\n    if (arguments.length === 1 && Array.isArray(arguments[0]))\n        return exports.normal.apply(exports, arguments[0]);\n    return exports.normal.apply(exports, arguments);\n};\n\n/**\n * Takes file system paths as variadic arguments and treats\n * each path as a location, in the URL sense, resolving each\n * new location based on the previous.  For example, if the\n * first argument is the absolute path of a JSON file, and\n * the second argument is a path mentioned in that JSON\n * file, `resolve` returns the absolute path of the\n * mentioned file.\n * @returns {String} path\n */\nexports.resolve = function () {\n    var root = \"\";\n    var parents = [];\n    var children = [];\n    var leaf = \"\";\n    for (var i = 0; i < arguments.length; i++) {\n        var path = String(arguments[i]);\n        if (path == \"\")\n            continue;\n        var parts = path.split(exports.SEPARATORS_RE());\n        if (exports.isAbsolute(path)) {\n            root = parts.shift() + exports.SEPARATOR;\n            parents = [];\n            children = [];\n        }\n        leaf = parts.pop();\n        if (leaf == \".\" || leaf == \"..\") {\n            parts.push(leaf);\n            leaf = \"\";\n        }\n        for (var j = 0; j < parts.length; j++) {\n            var part = parts[j];\n            if (part == \".\" || part == \"\") {\n            } else if (part == \"..\") {\n                if (children.length) {\n                    children.pop();\n                } else {\n                    if (root) {\n                    } else {\n                        parents.push(\"..\");\n                    }\n                }\n            } else {\n                children.push(part);\n            }\n        };\n    }\n    path = parents.concat(children).join(exports.SEPARATOR);\n    if (path) leaf = exports.SEPARATOR + leaf;\n    return root + path + leaf;\n};\n\n/**\n * Takes paths as any number of arguments and reduces them\n * into a single path in normal form, removing all \".\" path\n * components, and reducing \"..\" path components by removing\n * the previous path component if possible.\n * @returns {String} path\n */\nexports.normal = function () {\n    var root = \"\";\n    var parents = [];\n    var children = [];\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n        var path = String(arguments[i]);\n        // empty paths have no affect\n        if (path === \"\")\n            continue;\n        var parts = path.split(exports.SEPARATORS_RE());\n        if (exports.isAbsolute(path)) {\n            root = parts.shift() + exports.SEPARATOR;\n            parents = [];\n            children = [];\n        }\n        for (var j = 0, jj = parts.length; j < jj; j++) {\n            var part = parts[j];\n            if (part === \".\" || part === \"\") {\n            } else if (part == \"..\") {\n                if (children.length) {\n                    children.pop();\n                } else {\n                    if (root) {\n                    } else {\n                        parents.push(\"..\");\n                    }\n                }\n            } else {\n                children.push(part);\n            }\n        }\n    }\n    path = parents.concat(children).join(exports.SEPARATOR);\n    return root + path;\n};\n\n/***\n * @returns {Boolean} whether the given path begins at the\n * root of the file system or a drive letter.\n */\nexports.isAbsolute = function (path) {\n    // for absolute paths on any operating system,\n    // the first path component always determines\n    // whether it is relative or absolute.  On Unix,\n    // it is empty, so [\"\", \"foo\"].join(\"/\") == \"/foo\",\n    // \"/foo\".split(\"/\") == [\"\", \"foo\"].\n    var parts = exports.split(path);\n    // split(\"\") == [].  \"\" is not absolute.\n    // split(\"/\") == [\"\", \"\"] is absolute.\n    // split(?) == [\"\"] does not occur.\n    if (parts.length == 0)\n        return false;\n    return exports.isRoot(parts[0]);\n};\n\n/**\n * @returns {Boolean} whether the given path does not begin\n * at the root of the file system or a drive letter.\n */\nexports.isRelative = function (path) {\n    return !exports.isAbsolute(path);\n};\n\n/**\n * @returns {Boolean} whether the given path component\n * corresponds to the root of the file system or a drive\n * letter, as applicable.\n */\nexports.isRoot = function (first) {\n    if (exports.SEPARATOR === \"\\\\\") {\n        return /[a-zA-Z]:$/.test(first);\n    } else {\n        return first == \"\";\n    }\n};\n\n/**\n * @returns {String} the Unix root path or corresponding\n * Windows drive for a given path.\n */\nexports.root = function (path) {\n    if (!exports.isAbsolute(path))\n        path = require(\"./fs\").absolute(path);\n    var parts = exports.split(path);\n    return exports.join(parts[0], \"\");\n};\n\n/**\n * @returns {String} the parent directory of the given path.\n */\nexports.directory = function (path) {\n    path = exports.normal(path);\n    var absolute = exports.isAbsolute(path);\n    var parts = exports.split(path);\n    // XXX needs to be sensitive to the root for\n    // Windows compatibility\n    if (parts.length) {\n        if (parts[parts.length - 1] == \"..\") {\n            parts.push(\"..\");\n        } else {\n            parts.pop();\n        }\n    } else {\n        parts.unshift(\"..\");\n    }\n    return parts.join(exports.SEPARATOR) || (\n        exports.isRelative(path) ?\n        \"\" : exports.ROOT\n    );\n};\n\n/**\n * @returns {String} the last component of a path, without\n * the given extension if the extension is provided and\n * matches the given file.\n * @param {String} path\n * @param {String} extention an optional extention to detect\n * and remove if it exists.\n */\nexports.base = function (path, extension) {\n    var base = path.split(exports.SEPARATORS_RE()).pop();\n    if (extension)\n        base = base.replace(\n            new RegExp(regExpEscape(extension) + \"$\"),\n            \"\"\n        );\n    return base;\n};\n\n/**\n * @returns {String} the extension (e.g., `txt`) of the file\n * at the given path.\n */\nexports.extension = function (path) {\n    path = exports.base(path);\n    path = path.replace(/^\\.*/, \"\");\n    var index = path.lastIndexOf(\".\");\n    return index <= 0 ? \"\" : path.substring(index);\n};\n\n})(typeof exports !== \"undefined\" ? exports : FS_BOOT = {});\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/fs-common.js":"var Q = require(\"q\");\nvar Boot = require(\"./fs-boot\");\nvar RootFs = require(\"./fs-root\");\nvar MockFs = require(\"./fs-mock\");\n\n// TODO patternToRegExp\n// TODO glob\n// TODO match\n\nvar concat = function (arrays) {\n    return Array.prototype.concat.apply([], arrays);\n};\n\nexports.update = function (exports, workingDirectory) {\n\n    for (var name in Boot) {\n        exports[name] = Boot[name];\n    }\n\n    /**\n     * Read a complete file.\n     * @param {String} path    Path to the file.\n     * @param {String} [options.flags]  The mode to open the file with.\n     * @param {String} [options.charset]  The charset to open the file with.\n     * @param {Object} [options]   An object with options.\n     * second argument.\n     * @returns {Promise * (String || Buffer)}\n     */\n    exports.read = function (path, flags, charset, options) {\n        if (typeof flags === \"object\") {\n            options = flags;\n        } else if (typeof charset === \"object\") {\n            options = charset;\n            options.flags = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.charset = charset;\n        }\n        options.flags = options.flags || \"r\";\n        return Q.when(this.open(path, options), function (stream) {\n            return stream.read();\n        }, function (error) {\n            error.message = \"Can't read \" + path + \" because \" + error.message;\n            error.path = path;\n            error.flags = flags;\n            error.charset = charset;\n            throw error;\n        });\n    };\n\n    /**\n     * Write content to a file, overwriting the existing content.\n     * @param {String} path    Path to the file.\n     * @param {String || Buffer} content\n     * @param {String} [options.flags]  The mode to open the file with.\n     * @param {String} [options.charset]  The charset to open the file with.\n     * @param {Object} [options]   An object with options.\n     * @returns {Promise * Undefined} a promise that resolves\n     * when the writing is complete.\n     */\n    exports.write = function (path, content, flags, charset, options) {\n        var self = this;\n        if (typeof flags === \"object\") {\n            options = flags;\n        } else if (typeof charset === \"object\") {\n            options = charset;\n            options.flags = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.charset = charset;\n        }\n        flags = options.flags || \"w\";\n        if (flags.indexOf(\"b\") !== -1) {\n            if (!(content instanceof Buffer)) {\n                content = new Buffer(content);\n            }\n        } else if (content instanceof Buffer) {\n            flags += \"b\";\n        }\n        options.flags = flags;\n        return Q.when(self.open(path, options), function (stream) {\n            return Q.when(stream.write(content), function () {\n                return stream.close();\n            });\n        });\n    };\n\n    /**\n     * Append content to the end of a file.\n     * @param {String} path    Path to the file.\n     * @param {String || Buffer} content\n     * @param {String} [options.flags]  The mode to open the file with.\n     * @param {String} [options.charset]  The charset to open the file with.\n     * @param {Object} [options]   An object with options.\n     * @returns {Promise * Undefined} a promise that resolves\n     * when the writing is complete.\n     */\n    exports.append = function (path, content, flags, charset, options) {\n        var self = this;\n        if (typeof flags === \"object\") {\n            options = flags;\n        } else if (typeof charset === \"object\") {\n            options = charset;\n            options.flags = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.charset = charset;\n        }\n        flags = options.flags || \"a\";\n        if (content instanceof Buffer) {\n            flags += \"b\";\n        }\n        options.flags = flags;\n        return Q.when(self.open(path, options), function (stream) {\n            return Q.when(stream.write(content), function () {\n                return stream.close();\n            });\n        });\n    };\n\n    exports.move = function (source, target) {\n        var self = this;\n        return this.rename(source, target)\n        .catch(function (error) {\n            if (error.crossDevice) {\n                return self.copyTree(source, target)\n                .then(function () {\n                    return self.removeTree(source);\n                });\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    exports.copy = function (source, target) {\n        var self = this;\n        return Q.when(self.stat(source), function (stat) {\n            var mode = stat.node.mode;\n            return Q.all([\n                self.open(source, {flags: \"rb\"}),\n                self.open(target, {flags: \"wb\", mode: mode})\n            ]);\n        })\n        .spread(function (reader, writer) {\n            return Q.when(reader.forEach(function (block) {\n                return writer.write(block);\n            }), function () {\n                return Q.all([\n                    reader.close(),\n                    writer.close()\n                ]);\n            });\n        });\n    };\n\n    exports.copyTree = function (source, target) {\n        var self = this;\n        return Q.when(self.stat(source), function (stat) {\n            if (stat.isFile()) {\n                return self.copy(source, target);\n            } else if (stat.isDirectory()) {\n                return self.exists(target).then(function (targetExists) {\n                    function copySubTree() {\n                        return Q.when(self.list(source), function (list) {\n                            return Q.all(list.map(function (child) {\n                                return self.copyTree(\n                                    self.join(source, child),\n                                    self.join(target, child)\n                                );\n                            }));\n                        });\n                    }\n                    if (targetExists) {\n                        return copySubTree();\n                    } else {\n                        return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);\n                    }\n                });\n            } else if (stat.isSymbolicLink()) {\n                // TODO copy the link and type with readPath (but what about\n                // Windows junction type?)\n                return self.symbolicCopy(source, target);\n            }\n        });\n    };\n\n    exports.listTree = function (basePath, guard) {\n        var self = this;\n        basePath = String(basePath || '');\n        if (!basePath)\n            basePath = \".\";\n        guard = guard || function () {\n            return true;\n        };\n        var stat = self.stat(basePath);\n        return Q.when(stat, function (stat) {\n            var paths = [];\n            var mode; // true:include, false:exclude, null:no-recur\n            try {\n                var include = guard(basePath, stat);\n            } catch (exception) {\n                return Q.reject(exception);\n            }\n            return Q.when(include, function (include) {\n                if (include) {\n                    paths.push([basePath]);\n                }\n                if (include !== null && stat.isDirectory()) {\n                    return Q.when(self.list(basePath), function (children) {\n                        paths.push.apply(paths, children.map(function (child) {\n                            var path = self.join(basePath, child);\n                            return self.listTree(path, guard);\n                        }));\n                        return paths;\n                    });\n                } else {\n                    return paths;\n                }\n            });\n        }, function noSuchFile(reason) {\n            return [];\n        }).then(Q.all).then(concat);\n    };\n\n    exports.listDirectoryTree = function (path) {\n        return this.listTree(path, function (path, stat) {\n            return stat.isDirectory();\n        });\n    };\n\n    exports.makeTree = function (path, mode) {\n        path = String(path);\n        var self = this;\n        var parts = self.split(path);\n        var at = [];\n        if (self.isAbsolute(path)) {\n            // On Windows use the root drive (e.g. \"C:\"), on *nix the first\n            // part is the falsey \"\", and so use the ROOT (\"/\")\n            at.push(parts.shift() || self.ROOT);\n        }\n        return parts.reduce(function (parent, part) {\n            return Q.when(parent, function () {\n                at.push(part);\n                var parts = self.join(at) || \".\";\n                var made = self.makeDirectory(parts, mode);\n                return Q.when(made, null, function rejected(error) {\n                    // throw away errors for already made directories\n                    if (error.exists) {\n                        return;\n                    } else {\n                        throw error;\n                    }\n                });\n            });\n        }, undefined);\n    };\n\n    exports.removeTree = function (path) {\n        var self = this;\n        return Q.when(self.statLink(path), function (stat) {\n            if (stat.isSymbolicLink()) {\n                return self.remove(path);\n            } else if (stat.isDirectory()) {\n                return self.list(path)\n                .then(function (list) {\n                    // asynchronously remove every subtree\n                    return Q.all(list.map(function (name) {\n                        return self.removeTree(self.join(path, name));\n                    }))\n                    .then(function () {\n                        return self.removeDirectory(path);\n                    });\n                });\n            } else {\n                return self.remove(path);\n            }\n        });\n    };\n\n    exports.symbolicCopy = function (source, target, type) {\n        var self = this;\n        return Q.when(self.relative(target, source), function (relative) {\n            return self.symbolicLink(target, relative, type || \"file\");\n        });\n    };\n\n    exports.exists = function (path) {\n        return Q.when(this.stat(path), function () {\n            return true;\n        }, function () {\n            return false;\n        });\n    };\n\n    exports.isFile = function (path) {\n        return Q.when(this.stat(path), function (stat) {\n            return stat.isFile();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.isDirectory = function (path) {\n        return Q.when(this.stat(path), function (stat) {\n            return stat.isDirectory();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.isSymbolicLink = function (path) {\n        return Q.when(this.statLink(path), function (stat) {\n            return stat.isSymbolicLink();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.lastModified = function (path) {\n        var self = this;\n        return self.stat(path).invoke('lastModified');\n    };\n\n    exports.lastAccessed = function (path) {\n        var self = this;\n        return self.stat(path).invoke('lastAccessed');\n    };\n\n    exports.absolute = function (path) {\n        if (this.isAbsolute(path))\n            return this.normal(path);\n        return this.join(workingDirectory(), path);\n    };\n\n    exports.relative = function (source, target) {\n        var self = this;\n        return Q.when(this.isDirectory(source), function (isDirectory) {\n            if (isDirectory) {\n                return self.relativeFromDirectory(source, target);\n            } else {\n                return self.relativeFromFile(source, target);\n            }\n        });\n    };\n\n    exports.relativeFromFile = function (source, target) {\n        var self = this;\n        source = self.absolute(source);\n        target = self.absolute(target);\n        source = source.split(self.SEPARATORS_RE());\n        target = target.split(self.SEPARATORS_RE());\n        source.pop();\n        while (\n            source.length &&\n            target.length &&\n            target[0] == source[0]\n        ) {\n            source.shift();\n            target.shift();\n        }\n        while (source.length) {\n            source.shift();\n            target.unshift(\"..\");\n        }\n        return target.join(self.SEPARATOR);\n    };\n\n    exports.relativeFromDirectory = function (source, target) {\n        if (!target) {\n            target = source;\n            source = workingDirectory();\n        }\n        source = this.absolute(source);\n        target = this.absolute(target);\n        source = source.split(this.SEPARATORS_RE());\n        target = target.split(this.SEPARATORS_RE());\n        if (source.length === 2 && source[1] === \"\")\n            source.pop();\n        while (\n            source.length &&\n            target.length &&\n            target[0] == source[0]\n        ) {\n            source.shift();\n            target.shift();\n        }\n        while (source.length) {\n            source.shift();\n            target.unshift(\"..\");\n        }\n        return target.join(this.SEPARATOR);\n    };\n\n    exports.contains = function (parent, child) {\n        var i, ii;\n        parent = this.absolute(parent);\n        child = this.absolute(child);\n        parent = parent.split(this.SEPARATORS_RE());\n        child = child.split(this.SEPARATORS_RE());\n        if (parent.length === 2 && parent[1] === \"\")\n            parent.pop();\n        if (parent.length > child.length)\n            return false;\n        for (i = 0, ii = parent.length; i < ii; i++) {\n            if (parent[i] !== child[i])\n                break;\n        }\n        return i == ii;\n    };\n\n    exports.reroot = reroot;\n    function reroot(path) {\n        var self = this;\n        path = path || this.ROOT;\n        return RootFs(self, path);\n    }\n\n    exports.toObject = function (path) {\n        var self = this;\n        var list = self.listTree(path || \"\", function (path, stat) {\n            return stat.isFile();\n        });\n        return Q.when(list, function (list) {\n            var tree = {};\n            return Q.all(list.map(function (path) {\n                return Q.when(self.read(path, \"rb\"), function (content) {\n                    tree[path] = content;\n                });\n            })).then(function () {\n                return tree;\n            });\n        });\n    };\n\n    exports.merge = function (fss) {\n        var tree = {};\n        var done;\n        fss.forEach(function (fs) {\n            done = Q.when(done, function () {\n                return fs.listTree(\"\", function (path, stat) {\n                    return stat.isFile();\n                })\n                .then(function (list) {\n                    return Q.all(list.map(function (path) {\n                        return Q.when(fs.read(path, \"rb\"), function (content) {\n                            tree[path] = content;\n                        });\n                    }));\n                });\n            });\n        })\n        return Q.when(done, function () {\n            return MockFs(tree);\n        });\n    };\n\n    exports.Stats = Stats;\n    function Stats(nodeStat) {\n        this.node = nodeStat;\n        this.size = nodeStat.size;\n    }\n\n    var stats = [\n        \"isDirectory\",\n        \"isFile\",\n        \"isBlockDevice\",\n        \"isCharacterDevice\",\n        \"isSymbolicLink\",\n        \"isFIFO\",\n        \"isSocket\"\n    ];\n\n    stats.forEach(function (name) {\n        Stats.prototype[name] = function () {\n            return this.node[name]();\n        };\n    });\n\n    Stats.prototype.lastModified = function () {\n        return new Date(this.node.mtime);\n    };\n\n    Stats.prototype.lastAccessed = function () {\n        return new Date(this.node.atime);\n    };\n\n}\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/fs-root.js":"\nvar Q = require(\"q\");\nvar BOOT = require(\"./fs-boot\");\nvar COMMON = require(\"./fs-common\");\n\nmodule.exports = RootFs;\n\nfunction RootFs(outer, root) {\n    var inner = Object.create(BOOT);\n\n    function attenuate(path) {\n\n        // the machinations of projecting a path inside a\n        // subroot\n        var actual;\n        // if it's absolute, we want the path relative to\n        // the root of the inner file system\n        if (outer.isAbsolute(path)) {\n            actual = outer.relativeFromDirectory(outer.ROOT, path);\n        } else {\n            actual = path;\n        }\n        // we join the path onto the root of the inner file\n        // system so that parent references from the root\n        // return to the root, emulating standard unix\n        // behavior\n        actual = outer.join(outer.ROOT, actual);\n        // then we reconstruct the path relative to the\n        // inner root\n        actual = outer.relativeFromDirectory(outer.ROOT, actual);\n        // and rejoin it on the outer root\n        actual = outer.join(root, actual);\n        // and find the corresponding real path\n        return outer.canonical(actual)\n        .then(function (actual) {\n            return actual;\n        }, function () {\n            return actual;\n        }).then(function (actual) {\n            // and verify that the outer canonical path is\n            // actually inside the inner canonical path, to\n            // prevent break-outs\n            if (outer.contains(root, actual)) {\n                return {\n                    \"inner\": outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),\n                    \"outer\": actual\n                };\n            } else {\n                return Q.reject(\"Can't find: \" + JSON.stringify(path));\n            }\n        });\n    }\n\n    function workingDirectory() {\n        return outer.ROOT;\n    }\n\n    COMMON.update(inner, workingDirectory);\n\n    inner.list = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.list(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't list \" + JSON.stringify(path));\n        });\n    };\n\n    inner.open = function (path, flags, charset) {\n        return attenuate(path).then(function (path) {\n            return outer.open(path.outer, flags, charset);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't open \" + JSON.stringify(path));\n        });\n    };\n\n    inner.stat = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.stat(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't stat \" + JSON.stringify(path));\n        });\n    };\n\n    inner.statLink = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.statLink(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't statLink \" + JSON.stringify(path));\n        });\n    };\n\n    inner.canonical = function (path) {\n        return attenuate(path).then(function (path) {\n            return path.inner;\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't find canonical of \" + JSON.stringify(path));\n        });\n    };\n\n    inner.makeDirectory = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.makeDirectory(path.outer);\n        }).catch(function (error) {\n            throw new Error(\"Can't make directory \" + JSON.stringify(path));\n        });\n    };\n\n    inner.removeDirectory = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.removeDirectory(path.outer);\n        }).catch(function (error) {\n            throw new Error(\"Can't remove directory \" + JSON.stringify(path));\n        });\n    };\n\n    inner.remove = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.remove(path.outer);\n        }).catch(function (error) {\n            throw new Error(\"Can't remove \" + JSON.stringify(path));\n        });\n    };\n\n    inner.makeTree = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.makeTree(path.outer);\n        }).catch(function (error) {\n            throw new Error(\"Can't make tree \" + JSON.stringify(path));\n        });\n    };\n\n    inner.removeTree = function (path) {\n        return attenuate(path).then(function (path) {\n            return outer.removeTree(path.outer);\n        }).catch(function (error) {\n            throw new Error(\"Can't remove tree \" + JSON.stringify(path));\n        });\n    };\n\n    return Q.when(outer.canonical(root), function (_root) {\n        root = _root;\n        return inner;\n    });\n}\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/fs-mock.js":"\nvar Q = require(\"q\");\nvar Boot = require(\"./fs-boot\");\nvar Common = require(\"./fs-common\");\nvar BufferStream = require(\"./buffer-stream\");\nvar Reader = require(\"./reader\");\nvar Set = require(\"collections/set\");\n\nmodule.exports = MockFs;\n\nfunction MockFs(files, workingDirectory) {\n    if (!(this instanceof MockFs)) {\n        return new MockFs(files, workingDirectory);\n    }\n    this._root = new DirectoryNode(this, \"/\");\n\n    function init() {\n        // construct a file tree\n    }\n\n    Common.update(this, function () {\n        return workingDirectory;\n    });\n\n    workingDirectory = workingDirectory || this.ROOT;\n    if (files) {\n        this._init(files);\n    }\n}\n\nMockFs.prototype = Object.create(Boot);\n\nMockFs.prototype._init = function (files, tree) {\n    tree = tree || this.ROOT;\n    Object.keys(files).forEach(function (path) {\n        var content = files[path];\n        path = this.join(tree, path);\n        var directory = this.directory(path);\n        var base = this.base(path);\n        var directoryNode = this._root._walk(directory, true);\n        var fileNode = new FileNode(this);\n        if (!(content instanceof Buffer)) {\n            if (typeof content === \"object\") {\n                // make directory\n                this._root._walk(path, true);\n                // make content\n                this._init(content, path);\n                return;\n            } else {\n                content = new Buffer(String(content), \"utf-8\");\n            }\n        }\n        directoryNode._entries[base] = fileNode;\n        fileNode._chunks = [content];\n    }, this);\n};\n\nMockFs.prototype.list = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path)._follow(path);\n        if (!node.isDirectory()) {\n            new Error(\"Can't list non-directory: \" + JSON.stringify(path));\n        }\n        return Object.keys(node._entries).sort();\n    });\n};\n\nMockFs.prototype.open = function (path, flags, charset, options) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var base = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't find \" + path + \" because \" + directory + \" is not a directory\");\n        }\n        if (typeof flags == \"object\") {\n            options = flags;\n            flags = options.flags;\n            charset = options.charset;\n        } else {\n            options = options || {};\n        }\n        flags = flags || \"r\";\n        var binary = flags.indexOf(\"b\") >= 0;\n        var write = flags.indexOf(\"w\") >= 0;\n        var append = flags.indexOf(\"a\") >= 0;\n        if (!binary) {\n            charset = charset || \"utf-8\";\n        }\n        if (write || append) {\n            if (!node._entries[base]) {\n                node._entries[base] = new FileNode(this);\n                if (\"mode\" in options) {\n                    node._entries[base].mode = options.mode;\n                }\n            }\n            var fileNode = node._entries[base]._follow(path);\n            if (!fileNode.isFile()) {\n                throw new Error(\"Can't write non-file \" + path);\n            }\n            fileNode.mtime = Date.now();\n            fileNode.atime = Date.now();\n            if (!append) {\n                fileNode._chunks.length = 0;\n            }\n            return new BufferStream(fileNode._chunks, charset);\n        } else { // read\n            if (!node._entries[base]) {\n                throw new Error(\"Can't read non-existant \" + path);\n            }\n            var fileNode = node._entries[base]._follow(path);\n            if (!fileNode.isFile()) {\n                throw new Error(\"Can't read non-file \" + path);\n            }\n            fileNode.atime = Date.now();\n            if (\"begin\" in options && \"end\" in options) {\n                return new BufferStream(\n                    [\n                        Reader.join(fileNode._chunks)\n                        .slice(options.begin, options.end)\n                    ],\n                    charset\n                );\n            } else {\n                return new BufferStream(fileNode._chunks, charset);\n            }\n        }\n    });\n};\n\nMockFs.prototype.remove = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't remove file from non-directory: \" + path);\n        }\n        if (!node._entries[name]) {\n            throw new Error(\"Can't remove non-existant file: \" + path);\n        }\n        if (node._entries[name].isDirectory()) {\n            throw new Error(\"Can't remove directory. Use removeDirectory: \" + path);\n        }\n        delete node._entries[name];\n    });\n};\n\nMockFs.prototype.makeDirectory = function (path, mode) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            var error =  new Error(\"Can't make directory in non-directory: \" + path);\n            error.code = \"EEXISTS\";\n            error.exists = true;\n            throw error;\n        }\n        if (node._entries[name]) {\n            var error = new Error(\"Can't make directory. Entry exists: \" + path);\n            error.code = \"EISDIR\";\n            error.exists = true;\n            error.isDirectory = true;\n            throw error;\n        }\n        node._entries[name] = new DirectoryNode(self);\n        if (mode) {\n            node._entries[name].mode = mode;\n        }\n    });\n};\n\nMockFs.prototype.removeDirectory = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't remove directory from non-directory: \" + path);\n        }\n        if (!node._entries[name]) {\n            throw new Error(\"Can't remove non-existant directory: \" + path);\n        }\n        if (!node._entries[name].isDirectory()) {\n            throw new Error(\"Can't remove non-directory: \" + path);\n        }\n        delete node._entries[name];\n    });\n};\n\nMockFs.prototype.stat = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return new self.Stats(self._root._walk(path)._follow(path));\n    });\n};\n\nMockFs.prototype.statLink = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return new self.Stats(self._root._walk(path));\n    });\n};\n\nMockFs.prototype.link = function (source, target) {\n    var self = this;\n    return Q.fcall(function () {\n        source = self.absolute(source);\n        target = self.absolute(target);\n        var sourceNode = self._root._walk(source)._follow(source);\n        if (!sourceNode.isFile()) {\n            throw new Error(\"Can't link non-file: \" + source);\n        }\n        var directory = self.directory(target);\n        var base = self.base(target);\n        var targetNode = self._root._walk(directory)._follow(directory);\n        if (!targetNode.isDirectory()) {\n            throw new Error(\"Can't create link in non-directory: \" + target);\n        }\n        if (targetNode._entries[base] && targetNode._entries[base].isDirectory()) {\n            throw new Error(\"Can't overwrite existing directory with hard link: \" + target);\n        }\n        targetNode._entries[base] = sourceNode;\n    });\n};\n\nMockFs.prototype.symbolicLink = function (target, relative, type) {\n    var self = this;\n    return Q.fcall(function () {\n        target = self.absolute(target);\n        var directory = self.directory(target);\n        var base = self.base(target);\n        var node = self._root._walk(directory);\n        if (node._entries[base] && node._entries[base].isDirectory()) {\n            throw new Error(\"Can't overwrite existing directory with symbolic link: \" + target);\n        }\n        node._entries[base] = new LinkNode(self, relative);\n    });\n};\n\nMockFs.prototype.chown = function (path, owner) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        self._root._walk(path)._follow(path)._owner = owner;\n    });\n};\n\nMockFs.prototype.chmod = function (path, mode) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        self._root._walk(path)._follow(path).mode = mode;\n    });\n};\n\nMockFs.prototype.rename = function (source, target) {\n    var self = this;\n    return Q.fcall(function () {\n        source = self.absolute(source);\n        target = self.absolute(target);\n\n        var sourceDirectory = self.directory(source);\n        var sourceDirectoryNode = self._root._walk(sourceDirectory)._follow(sourceDirectory);\n        var sourceName = self.base(source);\n        var sourceNode = sourceDirectoryNode._entries[sourceName];\n\n        if (!sourceNode) {\n            var error = new Error(\"Can't copy non-existent file: \" + source);\n            error.code = \"ENOENT\";\n            throw error;\n        }\n\n        sourceNode = sourceNode._follow(source);\n\n        // check again after following symbolic links\n        if (!sourceNode) {\n            var error = new Error(\"Can't copy non-existent file: \" + source);\n            error.code = \"ENOENT\";\n            throw error;\n        }\n\n        var targetDirectory = self.directory(target);\n        var targetDirectoryNode = self._root._walk(targetDirectory)._follow(targetDirectory);\n        var targetName = self.base(target);\n        var targetNode = targetDirectoryNode._entries[targetName]; // might not exist, not followed\n\n        if (targetNode) {\n            targetNode = targetNode._follow(target);\n        }\n\n        if (targetNode && targetNode.isDirectory()) {\n            var error = new Error(\"Can't copy over existing directory: \" + target);\n            error.code = \"EISDIR\";\n            throw error;\n        }\n\n        // do not copy over self, even with symbolic links to confuse the issue\n        if (targetNode === sourceNode) {\n            return;\n        }\n\n        targetDirectoryNode._entries[targetName] = sourceNode;\n        delete sourceDirectoryNode._entries[sourceName];\n    });\n};\n\nMockFs.prototype.readLink = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path);\n        if (!self.isSymbolicLink()) {\n            throw new Error(\"Can't read non-symbolic link: \" + path);\n        }\n        return node._link;\n    });\n};\n\nMockFs.prototype.canonical = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return self._root._canonical(path);\n    });\n};\n\nMockFs.mock = mock;\nfunction mock(fs, root) {\n    return Q.when(fs.listTree(root), function (list) {\n        var tree = {};\n        return Q.all(list.map(function (path) {\n            var actual = fs.join(root, path);\n            var relative = fs.relativeFromDirectory(root, actual);\n            return Q.when(fs.stat(actual), function (stat) {\n                if (stat.isFile()) {\n                    return Q.when(fs.read(path, \"rb\"), function (content) {\n                        tree[relative] = content;\n                    });\n                }\n            });\n        })).then(function () {\n            return MockFs(tree);\n        });\n    });\n}\n\nfunction Node(fs) {\n    if (!fs)\n        throw new Error(\"FS required argument\");\n    this._fs = fs;\n    this.atime = this.mtime = Date.now();\n    this.mode = parseInt(\"0644\", 8);\n    this._owner = null;\n}\n\nNode.prototype._walk = function (path, make, via) {\n    var parts = this._fs.split(path);\n    if (this._fs.isAbsolute(path)) {\n        parts.shift();\n        return this._fs._root._walkParts(parts, make, this._fs.ROOT);\n    } else {\n        return this._walkParts(parts, make, via || this._fs.ROOT);\n    }\n};\n\nNode.prototype._walkParts = function (parts, make, via) {\n    if (parts.length === 0) {\n        return this;\n    } else {\n        var part = parts.shift();\n        if (part === \"\") {\n            return this._walkParts(parts, make, this._fs.join(via, part));\n        } else {\n            var error = new Error(\"Can't find \" + JSON.stringify(this._fs.resolve(part, this._fs.join(parts))) + \" via \" + JSON.stringify(via));\n            error.code = \"ENOENT\";\n            throw error;\n        }\n    }\n};\n\nNode.prototype._canonical = function (path) {\n    if (!this._fs.isAbsolute(path)) {\n        throw new Error(\"Path must be absolute for _canonical: \" + path);\n    }\n    var parts = this._fs.split(path);\n    parts.shift();\n    var via = this._fs.ROOT;\n    return via + this._fs._root._canonicalParts(parts, via);\n};\n\nNode.prototype._canonicalParts = function (parts, via) {\n    if (parts.length === 0) {\n        return via;\n    }\n    return this._fs.join(via, this._fs.join(parts));\n};\n\nNode.prototype._follow = function () {\n    return this;\n};\n\nNode.prototype._touch = function () {\n    this.mtime = Date.now();\n};\n\nvar stats = [\n    \"isDirectory\",\n    \"isFile\",\n    \"isBlockDevice\",\n    \"isCharacterDevice\",\n    \"isSymbolicLink\",\n    \"isFIFO\",\n    \"isSocket\"\n];\n\nstats.forEach(function (name) {\n    Node.prototype[name] = function () {\n        return false;\n    };\n});\n\nNode.prototype.lastAccessed = function () {\n    return this.atime;\n};\n\nNode.prototype.lastModified = function () {\n    return this.mtime;\n};\n\nfunction FileNode(fs) {\n    Node.call(this, fs);\n    this._chunks = [];\n}\n\nFileNode.prototype = Object.create(Node.prototype);\n\nFileNode.prototype.isFile = function () {\n    return true;\n};\n\nObject.defineProperty(FileNode.prototype, \"size\", {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n        return this._chunks.reduce(function (size, chunk) {\n            return size += chunk.length;\n        }, 0);\n    }\n});\n\nfunction DirectoryNode(fs) {\n    Node.call(this, fs);\n    this._entries = Object.create(null);\n    this.mode = parseInt(\"0755\", 8);\n}\n\nDirectoryNode.prototype = Object.create(Node.prototype);\n\nDirectoryNode.prototype.isDirectory = function () {\n    return true;\n};\n\nDirectoryNode.prototype._walkParts = function (parts, make, via) {\n    via = via || this._fs.ROOT;\n    if (parts.length === 0) {\n        return this;\n    }\n    var part = parts.shift();\n    if (part === \"\") {\n        return this._walkParts(parts, make, this._fs.join(via, part));\n    }\n    if (!this._entries[part]) {\n        if (make) {\n            this._entries[part] = new DirectoryNode(this._fs);\n        } else {\n            var error = new Error(\"Can't find \" + JSON.stringify(this._fs.join(parts)) + \" via \" + JSON.stringify(via));\n            error.code = \"ENOENT\";\n            throw error;\n\n        }\n    }\n    return this._entries[part]._walkParts(parts, make, this._fs.join(via, part));\n};\n\nDirectoryNode.prototype._canonicalParts = function (parts, via) {\n    if (parts.length === 0) {\n        return via;\n    }\n    var part = parts.shift();\n    if (part === \"\") {\n        return via;\n    }\n    if (via === this._fs.ROOT) {\n        via = \"\";\n    }\n    if (!this._entries[part]) {\n        return this._fs.join(via, part, this._fs.join(parts));\n    }\n    return this._entries[part]._canonicalParts(\n        parts,\n        this._fs.join(via, part)\n    );\n};\n\nfunction LinkNode(fs, link) {\n    Node.call(this, fs);\n    this._link = link;\n}\n\nLinkNode.prototype = Object.create(Node.prototype);\n\nLinkNode.prototype.isSymbolicLink = function () {\n    return true;\n};\n\nLinkNode.prototype._follow = function (via, memo) {\n    memo = memo || Set();\n    if (memo.has(this)) {\n        var error = new Error(\"Can't follow symbolic link cycle at \" + JSON.stringify(via));\n        error.code = \"ELOOP\";\n        throw error;\n    }\n    memo.add(this);\n    var link = this._fs.join(via, \"..\", this._link);\n    return this._walk(link, null, \"<link>\")._follow(link, memo);\n};\n\nLinkNode.prototype._canonicalParts = function (parts, via) {\n    return this._fs.relativeFromDirectory(this._fs.ROOT,\n        this._fs._root._canonical(\n            this._fs.absolute(this._fs.join(via, \"..\", this._link))\n        )\n    );\n};\n\n// cycle breaking\nvar FS = require(\"./fs\");\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/fs.js":"/**\n * An asynchronous local file system API, based on a subset\n * of the `narwhal/fs` API and the `narwhal/promise` API,\n * such that the method names are the same but some return\n * values are promises instead of fully resolved values.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar FS = require(\"fs\"); // node\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\nvar Writer = require(\"./writer\");\nvar Common = require(\"./fs-common\");\nvar Mock = require(\"./fs-mock\");\nvar Root = require(\"./fs-root\");\n\nCommon.update(exports, process.cwd);\nexports.Mock = Mock;\nexports.Root = Root;\n\n// facilitates AIMD (additive increase, multiplicative decrease) for backing off\nvar backOffDelay = 0;\nvar backOffFactor = 1.0001;\nfunction dampen(wrapped, thisp) {\n    var retry = function () {\n        var args = arguments;\n        var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();\n        return ready.then(function () {\n            return Q.when(wrapped.apply(thisp, args), function (stream) {\n                backOffDelay = Math.max(0, backOffDelay - 1);\n                return stream;\n            }, function (error) {\n                if (error.code === \"EMFILE\") {\n                    backOffDelay = (backOffDelay + 1) * backOffFactor;\n                    return retry.apply(null, args);\n                } else {\n                    throw error;\n                }\n            });\n        });\n    };\n    return retry;\n}\n\n/**\n * @param {String} path\n * @param {Object} options (flags, mode, bufferSize, charset, begin, end)\n * @returns {Promise * Stream} a stream from the `q-io` module.\n */\nexports.open = dampen(function (path, flags, charset, options) {\n    var self = this;\n    if (typeof flags == \"object\") {\n        options = flags;\n        flags = options.flags;\n        charset = options.charset;\n    }\n    options = options || {};\n    flags = flags || \"r\";\n    var nodeFlags = flags.replace(/b/g, \"\") || \"r\";\n    var nodeOptions = {\n        \"flags\": nodeFlags\n    };\n    if (\"bufferSize\" in options) {\n        nodeOptions.bufferSize = options.bufferSize;\n    }\n    if (\"mode\" in options) {\n        nodeOptions.mode = options.mode;\n    }\n    if (\"begin\" in options) {\n        nodeOptions.start = options.begin;\n        nodeOptions.end = options.end - 1;\n    }\n    if (flags.indexOf(\"b\") >= 0) {\n        if (charset) {\n            throw new Error(\"Can't open a binary file with a charset: \" + charset);\n        }\n    } else {\n        charset = charset || 'utf-8';\n    }\n    if (flags.indexOf(\"w\") >= 0 || flags.indexOf(\"a\") >= 0) {\n        var stream = FS.createWriteStream(String(path), nodeOptions);\n        return Writer(stream, charset);\n    } else {\n        var stream = FS.createReadStream(String(path), nodeOptions);\n        return Reader(stream, charset);\n    }\n});\n\nexports.remove = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    FS.unlink(path, function (error) {\n        if (error) {\n            error.message = \"Can't remove \" + JSON.stringify(path) + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\nexports.rename = function (source, target) {\n    source = String(source);\n    target = String(target);\n    return Q.ninvoke(FS, \"rename\", source, target)\n    .fail(function (error) {\n        if (error.code === \"EXDEV\") {\n            error.message = \"source and target are on different devices: \" + error.message;\n            error.crossDevice = true;\n        }\n        error.message = (\n            \"Can't move \" + JSON.stringify(source) + \" to \" +\n            JSON.stringify(target) + \" because \" + error.message\n        );\n        throw error;\n    });\n};\n\nexports.makeDirectory = function (path, mode) {\n    path = String(path);\n    var done = Q.defer();\n    if (typeof mode === \"string\") {\n        mode = parseInt(mode, 8);\n    } else if (mode === void 0) {\n        mode = parseInt('755', 8);\n    }\n    FS.mkdir(path, mode, function (error) {\n        if (error) {\n            if (error.code === \"EISDIR\") {\n                error.exists = true;\n                error.isDirectory = true;\n                error.message = \"directory already exists: \" + error.message;\n            }\n            if (error.code === \"EEXIST\") {\n                error.exists = true;\n                error.message = \"file exists at that path: \" + error.message;\n            }\n            error.message = \"Can't makeDirectory \" + JSON.stringify(path) + \" with mode \" + mode + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\nexports.removeDirectory = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    FS.rmdir(path, function (error) {\n        if (error) {\n            error.message = \"Can't removeDirectory \" + JSON.stringify(path) + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\n/**\n */\nexports.list = dampen(function (path) {\n    path = String(path);\n    var result = Q.defer();\n    FS.readdir(path, function (error, list) {\n        if (error) {\n            error.message = \"Can't list \" + JSON.stringify(path) + \": \" + error.message;\n            return result.reject(error);\n        } else {\n            result.resolve(list);\n        }\n    });\n    return result.promise;\n});\n\n/**\n * @param {String} path\n * @returns {Promise * Stat}\n */\nexports.stat = function (path) {\n    var self = this;\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.stat(path, function (error, stat) {\n            if (error) {\n                error.message = \"Can't stat \" + JSON.stringify(path) + \": \" + error;\n                done.reject(error);\n            } else {\n                done.resolve(new self.Stats(stat));\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.statLink = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.lstat(path, function (error, stat) {\n            if (error) {\n                error.message = \"Can't statLink \" + JSON.stringify(path) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve(stat);\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.statFd = function (fd) {\n    fd = Number(fd);\n    var done = Q.defer();\n    try {\n        FS.fstat(fd, function (error, stat) {\n            if (error) {\n                error.message = \"Can't statFd file descriptor \" + JSON.stringify(fd) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve(stat);\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.link = function (source, target) {\n    source = String(source);\n    target = String(target);\n    var done = Q.defer();\n    try {\n        FS.link(source, target, function (error) {\n            if (error) {\n                error.message = \"Can't link \" + JSON.stringify(source) + \" to \" + JSON.stringify(target) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\n// this lookup table translates the link types that Q-IO accepts (which have\n// been normalized to full words to be consistent with the naming convention)\nvar linkTypes = {\n    \"file\": \"file\",\n    \"directory\": \"dir\",\n    \"junction\": \"junction\"\n};\n\nexports.symbolicLink = function (target, relative, type) {\n    if (!linkTypes.hasOwnProperty(type)) {\n        console.warn(new Error(\"For Windows compatibility, symbolicLink must be called with a type argument \\\"file\\\", \\\"directory\\\", or \\\"junction\\\"\"));\n    }\n    type = linkTypes[type];\n    target = String(target);\n    relative = String(relative);\n    var done = Q.defer();\n    try {\n        FS.symlink(relative, target, type || 'file', function (error) {\n            if (error) {\n                error.message = \"Can't create symbolicLink \" + JSON.stringify(target) + \" to relative location \" + JSON.stringify(relative) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.chown = function (path, uid, gid) {\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.chown(path, uid, gid, function (error) {\n            if (error) {\n                error.message = \"Can't chown (change owner) of \" + JSON.stringify(path) + \" to user \" + JSON.stringify(uid) + \" and group \" + JSON.stringify(gid) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.chmod = function (path, mode) {\n    path = String(path);\n    mode = String(mode);\n    var done = Q.defer();\n    try {\n        FS.chmod(path, mode, function (error) {\n            if (error) {\n                error.message = \"Can't chmod (change permissions mode) of \" + JSON.stringify(path) + \" to (octal number) \" + mode.toString(8) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.canonical = function (path) {\n    var result = Q.defer();\n    FS.realpath(path, function (error, canonicalPath) {\n        if (error) {\n            error.message = \"Can't get canonical path of \" + JSON.stringify(path) + \" by way of C realpath: \" + error.message;\n            result.reject(error);\n        } else {\n            result.resolve(canonicalPath);\n        }\n    });\n    return result.promise;\n};\n\nexports.readLink = function (path) {\n    var result = Q.defer();\n    FS.readlink(path, function (error, path) {\n        if (error) {\n            error.message = \"Can't get link from \" + JSON.stringify(path) + \" by way of C readlink: \" + error.message;\n            result.reject(error);\n        } else {\n            result.resolve(path);\n        }\n    });\n    return result.promise;\n};\n\nexports.mock = function (path) {\n    return Mock.mock(this, path);\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/writer.js":"\nvar Q = require(\"q\");\n\n/**\n * Wraps a Node writable stream, providing an API similar to\n * Narwhal's synchronous `io` streams, except returning and\n * accepting promises for long-latency operations.\n *\n * @param stream any Node writable stream\n * @returns {Promise * Writer} a promise for the\n * text writer.\n */\nmodule.exports = Writer;\n\nvar version = process.versions.node.split('.');\nvar supportsFinish = version[0] >= 1 || version[1] >= 10;\n\nfunction Writer(_stream, charset) {\n    var self = Object.create(Writer.prototype);\n\n    if (charset && _stream.setEncoding) // TODO complain about inconsistency\n        _stream.setEncoding(charset);\n\n    var drained = Q.defer();\n\n    _stream.on(\"error\", function (reason) {\n        drained.reject(reason);\n        drained = Q.defer();\n    });\n\n    _stream.on(\"drain\", function () {\n        drained.resolve();\n        drained = Q.defer();\n    });\n\n    /***\n     * Writes content to the stream.\n     * @param {String} content\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the buffer is empty, meaning\n     * that all of the content has been sent.\n     */\n    self.write = function (content) {\n        if (!_stream.writeable && !_stream.writable)\n            return Q.reject(new Error(\"Can't write to non-writable (possibly closed) stream\"));\n        if (typeof content !== \"string\") {\n            content = new Buffer(content);\n        }\n        if (!_stream.write(content)) {\n            return drained.promise;\n        } else {\n            return Q.resolve();\n        }\n    };\n\n    /***\n     * Waits for all data to flush on the stream.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the buffer is empty\n     */\n    self.flush = function () {\n        return drained.promise;\n    };\n\n    /***\n     * Closes the stream, waiting for the internal buffer\n     * to flush.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the stream has finished writing,\n     * flushing, and closed.\n     */\n    self.close = function () {\n        var finished;\n\n        if (supportsFinish) { // new Streams, listen for `finish` event\n            finished = Q.defer();\n            _stream.on(\"finish\", function () {\n                finished.resolve();\n            });\n            _stream.on(\"error\", function (reason) {\n                finished.reject(reason);\n            });\n        }\n\n        _stream.end();\n        drained.resolve(); // we will get no further drain events\n        if (finished) { // closing not explicitly observable\n            return finished.promise;\n        } else {\n            return Q(); // just resolve for old Streams\n        }\n    };\n\n    /***\n     * Terminates writing on a stream, closing before\n     * the internal buffer drains.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the stream has finished closing.\n     */\n    self.destroy = function () {\n        _stream.destroy();\n        drained.resolve(); // we will get no further drain events\n        return Q.resolve(); // destruction not explicitly observable\n    };\n\n    self.node = _stream;\n\n    return Q(self); // todo returns the begin.promise\n}\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/fs2http.js":"\nvar Q = require(\"q\");\nvar HTTP = require(\"./http\");\nvar URL = require(\"url\");\n\nexports.Client = Client;\nfunction Client(fs) {\n    var self = Object.create(Client.prototype);\n\n    self.request = function (request) {\n        return Q.when(request, function (request) {\n            request = HTTP.normalizeRequest(request);\n            var url = URL.parse(request.url);\n            if (url.protocol !== \"file:\") {\n                return {\n                    status: 404,\n                    headers: {},\n                    body: [\"Can't access protocol \" + url.protocol]\n                };\n            } else {\n                var path = url.pathname;\n                return fs.open(path, {\n                    charset: request.charset\n                }).then(function (body) {\n                    return {\n                        status: 200,\n                        headers: {},\n                        body: body\n                    };\n                });\n            }\n        });\n    };\n\n    self.read = function (request, qualifier) {\n        qualifier = qualifier || function (response) {\n            return response.status === 200;\n        };\n        return Q.when(exports.request(request), function (response) {\n            if (!qualifier(response)){\n                var error = new Error(\"HTTP request failed with code \" + response.status);\n                error.response = response;\n                throw error;\n            }\n            return Q.invoke(response.body, \"read\");\n        });\n    };\n\n    return self;\n}\n\nexports.request = function (request) {\n    return Q.fcall(require.async || require, \"./fs\")\n    .then(function (fs) {\n        return Client(fs).request(request);\n    });\n};\n\nexports.read = function (request, qualifier) {\n    return Q.fcall(require.async || require, \"./fs\")\n    .then(function (fs) {\n        return Client(fs).read(request);\n    });\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http.js":"/**\n * A promise-based Q-JSGI server and client API.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar HTTP = require(\"http\"); // node\nvar HTTPS = require(\"https\"); // node\nvar URL = require(\"url2\"); // node\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\n\n/**\n * @param {respond(request Request)} respond a JSGI responder function that\n * receives a Request object as its argument.  The JSGI responder promises to\n * return an object of the form `{status, headers, body}`.  The status and\n * headers must be fully resolved, but the body may be a promise for an object\n * with a `forEach(write(chunk String))` method, albeit an array of strings.\n * The `forEach` method may promise to resolve when all chunks have been\n * written.\n * @returns a Node Server object.\n */\nexports.Server = function (respond) {\n    var self = Object.create(exports.Server.prototype);\n\n    var server = HTTP.createServer(function (_request, _response) {\n        var request = exports.ServerRequest(_request);\n        var response = exports.ServerResponse(_response);\n\n        var closed = Q.defer();\n        _request.on(\"end\", function (error, value) {\n            if (error) {\n                closed.reject(error);\n            } else {\n                closed.resolve(value);\n            }\n        });\n\n        Q.when(request, function (request) {\n            return Q.when(respond(request, response), function (response) {\n                if (!response)\n                    return;\n\n                _response.writeHead(response.status, response.headers);\n\n                if (response.onclose || response.onClose)\n                    Q.when(closed, response.onclose || response.onClose);\n\n                return Q.when(response.body, function (body) {\n                    var length;\n                    if (\n                        Array.isArray(body) &&\n                        (length = body.length) &&\n                        body.every(function (chunk) {\n                            return typeof chunk === \"string\"\n                        })\n                    ) {\n                        body.forEach(function (chunk, i) {\n                            if (i < length - 1) {\n                                _response.write(chunk, response.charset);\n                            } else {\n                                _response.end(chunk, response.charset);\n                            }\n                        });\n                    } else if (body) {\n                        var end;\n                        var done = body.forEach(function (chunk) {\n                            end = Q.when(end, function () {\n                                return Q.when(chunk, function (chunk) {\n                                    _response.write(chunk, response.charset);\n                                });\n                            });\n                        });\n                        return Q.when(done, function () {\n                            return Q.when(end, function () {\n                                _response.end();\n                            });\n                        });\n                    } else {\n                        _response.end();\n                    }\n                });\n\n            })\n        })\n        .done(); // should be .fail(self.emitter(\"error\"))\n\n    });\n\n    var stopped = Q.defer();\n    server.on(\"close\", function (err) {\n        if (err) {\n            stopped.reject(err);\n        } else {\n            stopped.resolve();\n        }\n    });\n\n    /***\n     * Stops the server.\n     * @returns {Promise * Undefined} a promise that will\n     * resolve when the server is stopped.\n     */\n    self.stop = function () {\n        server.close();\n        listening = undefined;\n        return stopped.promise;\n    };\n\n    var listening = Q.defer();\n    server.on(\"listening\", function (err) {\n        if (err) {\n            listening.reject(err);\n        } else {\n            listening.resolve(self);\n        }\n    });\n\n    /***\n     * Starts the server, listening on the given port\n     * @param {Number} port\n     * @returns {Promise * Undefined} a promise that will\n     * resolve when the server is ready to receive\n     * connections\n     */\n    self.listen = function (/*...args*/) {\n        if (typeof server.port !== \"undefined\")\n            return Q.reject(new Error(\"A server cannot be restarted or \" +\n            \"started on a new port\"));\n        server.listen.apply(server, arguments);\n        return listening.promise;\n    };\n\n    self.stopped = stopped.promise;\n\n    self.node = server;\n    self.nodeServer = server; // Deprecated\n    self.address = server.address.bind(server);\n\n    return self;\n};\n\nObject.defineProperties(exports.Server, {\n\n    port: {\n        get: function () {\n            return this.node.port;\n        }\n    },\n\n    host: {\n        get: function () {\n            return this.node.host;\n        }\n    }\n\n});\n\n/**\n * A wrapper for a Node HTTP Request, as received by\n * the Q HTTP Server, suitable for use by the Q HTTP Client.\n */\n\nexports.ServerRequest = function (_request, ssl) {\n    var request = Object.create(_request, requestDescriptor);\n    /*** {Array} HTTP version. (JSGI) */\n    request.version = _request.httpVersion.split(\".\").map(Math.floor);\n    /*** {String} HTTP method, e.g., `\"GET\"` (JSGI) */\n    request.method = _request.method;\n    /*** {String} path, starting with `\"/\"` */\n    request.path = _request.url;\n    /*** {String} pathInfo, starting with `\"/\"`, the\n     * portion of the path that has not yet\n     * been routed (JSGI) */\n    request._pathInfo = null;\n    /*** {String} scriptName, the portion of the path that\n     * has already been routed (JSGI) */\n    request.scriptName = \"\";\n    /*** {String} (JSGI) */\n    request.scheme = \"http\";\n\n    var address = _request.connection.address();\n    /*** {String} hostname */\n    if (_request.headers.host) {\n        request.hostname = _request.headers.host.split(\":\")[0];\n    } else {\n        request.hostname = address.address;\n    }\n    /*** {String} host */\n    request.port = address.port;\n    var defaultPort = request.port === (ssl ? 443 : 80);\n    request.host = request.hostname + (defaultPort ? \"\" : \":\" + request.port);\n\n    var socket = _request.socket;\n    /*** {String} */\n    request.remoteHost = socket.remoteAddress;\n    /*** {Number} */\n    request.remotePort = socket.remotePort;\n\n    /*** {String} url */\n    request.url = URL.format({\n        protocol: request.scheme,\n        host: _request.headers.host,\n        port: request.port === (ssl ? 443 : 80) ? null : request.port,\n        path: request.path\n    });\n    /*** A Q IO asynchronous text reader */\n    request.body = Reader(_request);\n    /*** {Object} HTTP headers (JSGI)*/\n    request.headers = _request.headers;\n    /*** The underlying Node request */\n    request.node = _request;\n    request.nodeRequest = _request; // Deprecated\n    /*** The underlying Node TCP connection */\n    request.nodeConnection = _request.connection;\n\n    return Q.when(request.body, function (body) {\n        request.body = body;\n        return request;\n    });\n};\n\nvar requestDescriptor = {\n    pathInfo: {\n        get: function () {\n            // Postpone this until the server requests it because\n            // decodeURIComponent may throw an error if the path is not valid.\n            // If we throw while making a server request, it will crash the\n            // server and be uncatchable.\n            if (this._pathInfo === null) {\n                this._pathInfo = decodeURIComponent(URL.parse(this.url).pathname);\n            }\n            return this._pathInfo;\n        },\n        set: function (pathInfo) {\n            this._pathInfo = pathInfo;\n        }\n    }\n};\n\nexports.ServerResponse = function (_response, ssl) {\n    var response = Object.create(_response);\n    response.ssl = ssl;\n    response.node = _response;\n    response.nodeResponse = _response; // Deprecated\n    return response;\n};\n\nexports.normalizeRequest = function (request) {\n    if (typeof request === \"string\") {\n        request = {url: request};\n    }\n    request.method = request.method || \"GET\";\n    request.headers = request.headers || {};\n    if (request.url) {\n        var url = URL.parse(request.url);\n        request.ssl = url.protocol === \"https:\";\n        request.hostname = url.hostname;\n        request.host = url.host;\n        request.port = +url.port;\n        request.path = (url.pathname || \"\") + (url.search || \"\");\n        request.auth = url.auth || void 0;\n    }\n    request.host = request.host || request.headers.host;\n    request.port = request.port || (request.ssl ? 443 : 80);\n    if (request.host && !request.hostname) {\n        request.hostname = request.host.split(\":\")[0];\n    }\n    if (request.hostname && request.port && !request.host) {\n        var defaultPort = request.ssl ? 443 : 80;\n        request.host = request.hostname + (defaultPort ? \"\" : \":\" + request.port);\n    }\n    request.headers.host = request.headers.host || request.host;\n    request.path = request.path || \"/\";\n    return request;\n};\n\nexports.normalizeResponse = function (response) {\n    if (response === void 0) {\n        return;\n    }\n    if (typeof response == \"string\") {\n        response = [response];\n    }\n    if (response.forEach) {\n        response = {\n            status: 200,\n            headers: {},\n            body: response\n        }\n    }\n    return response;\n};\n\n/**\n * Issues an HTTP request.\n *\n * @param {Request {host, port, method, path, headers,\n * body}} request (may be a promise)\n * @returns {Promise * Response} promise for a response\n */\nexports.request = function (request) {\n    return Q.when(request, function (request) {\n\n        request = exports.normalizeRequest(request);\n\n        var deferred = Q.defer();\n        var http = request.ssl ? HTTPS : HTTP;\n\n        var requestOptions = {\n            hostname: request.hostname,\n            port: request.port || (request.ssl ? 443 : 80),\n            localAddress: request.localAddress,\n            socketPath: request.socketPath,\n            method: request.method,\n            path: request.path,\n            headers: request.headers,\n            auth: request.auth // Generates the appropriate header\n        };\n\n        if (request.agent !== undefined) {\n            requestOptions.agent = request.agent;\n        }\n\n        var _request = http.request(requestOptions, function (_response) {\n            deferred.resolve(exports.ClientResponse(_response, request.charset));\n            _response.on(\"error\", function (error) {\n                // TODO find a better way to channel\n                // this into the response\n                console.warn(error && error.stack || error);\n                deferred.reject(error);\n            });\n        });\n\n        _request.on(\"error\", function (error) {\n            deferred.reject(error);\n        });\n\n        if (request.timeout) {\n            _request.setTimeout(request.timeout, function() {\n                _request.abort();\n            });\n        }\n\n        Q.when(request.body, function (body) {\n            var end, done;\n            if (body) {\n                done = body.forEach(function (chunk) {\n                    end = Q.when(end, function () {\n                        return Q.when(chunk, function (chunk) {\n                            _request.write(chunk, request.charset);\n                        });\n                    });\n                });\n            }\n            return Q.when(end, function () {\n                return Q.when(done, function () {\n                    _request.end();\n                });\n            });\n        }).done();\n\n        return deferred.promise;\n    });\n};\n\n/**\n * Issues a GET request to the given URL and returns\n * a promise for a `String` containing the entirety\n * of the response.\n *\n * @param {String} url\n * @returns {Promise * String} or a rejection if the\n * status code is not exactly 200.  The reason for the\n * rejection is the full response object.\n */\nexports.read = function (request, qualifier) {\n    qualifier = qualifier || function (response) {\n        return response.status === 200;\n    };\n    return Q.when(exports.request(request), function (response) {\n        if (!qualifier(response)){\n            var error = new Error(\"HTTP request failed with code \" + response.status);\n            error.response = response;\n            throw error;\n        }\n        return Q.post(response.body, 'read', []);\n    });\n};\n\n\n/**\n * A wrapper for the Node HTTP Response as provided\n * by the Q HTTP Client API, suitable for use by the\n * Q HTTP Server API.\n */\nexports.ClientResponse = function (_response, charset) {\n    var response = Object.create(exports.ClientResponse.prototype);\n    /*** {Number} HTTP status code */\n    response.status = _response.statusCode;\n    /*** HTTP version */\n    response.version = _response.httpVersion;\n    /*** {Object} HTTP headers */\n    response.headers = _response.headers;\n    /***\n     * A Q IO asynchronous text reader.\n     */\n    response.node = _response;\n    response.nodeResponse = _response; // Deprecated\n    response.nodeConnection = _response.connection; // Deprecated\n    return Q.when(Reader(_response, charset), function (body) {\n        response.body = body;\n        return response;\n    });\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/chain.js":"\nmodule.exports = Chain;\nfunction Chain(end) {\n    var self = Object.create(Chain.prototype);\n    self.end = end || function (next) {\n        return next;\n    };\n    return self;\n};\n\nChain.prototype.use = function (App /*, ...args*/) {\n    if (!App) throw new Error(\"App is not defined after \" + this.app);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var self = this;\n    this.end = (function (End) {\n        return function Self(next) {\n            if (self.end !== Self && !next) throw new Error(\"App chain is broken after \" + App);\n            return End(App.apply(null, [next].concat(args)));\n        };\n    })(this.end);\n    this.app = App;\n    return this;\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/content.js":"var Q = require(\"q\");\nvar Negotiate = require(\"./negotiate\");\nvar QS = require(\"qs\");\nvar URL = require(\"url2\");\n\n/**\n * Makes an app that returns a response with static content\n * from memory.\n * @param {Body} body a Q-JSGI\n * response body\n * @param {String} contentType\n * @param {Number} status\n * @returns {App} a Q-JSGI app\n */\nexports.Content = function (body, contentType, status) {\n    return function () {\n        return exports.content(body, contentType, status);\n    };\n};\n\n/**\n * Returns a Q-JSGI response with the given content.\n * @param {Body} content (optional) defaults to `[\"\"]`\n * @param {String} contentType (optional) defaults to `\"text/plain\"`\n * @param {Number} status (optional) defaults to `200`\n * @returns {Response}\n */\nexports.content =\nexports.ok = function (content, contentType, status) {\n    status = status || 200;\n    content = content || \"\";\n    if (typeof content === \"string\") {\n        content = [content];\n    }\n    contentType = contentType || \"text/plain\";\n    return {\n        \"status\": status,\n        \"headers\": {\n            \"content-type\": contentType\n        },\n        \"body\": content\n    };\n};\n\n/**\n * Wraps an app such that it expects to receive content\n * in the request body and passes that content as a string\n * to as the second argument to the wrapped JSGI app.\n *\n * @param {Function(Request, Object):Response} app\n * @returns {App}\n */\nexports.ContentRequest = function (app) {\n    return function (request, response) {\n        return Q.when(request.body.read(), function (body) {\n            return app(body, request, response);\n        });\n    };\n};\n\n/**\n * @param {Function(Request):Object}\n * @returns {App}\n */\nexports.Inspect = function (app) {\n    return Negotiate.Method({\"GET\": function (request, response) {\n        return Q.when(app(request, response), function (object) {\n            return {\n                status: 200,\n                headers: {\n                    \"content-type\": \"text/plain\"\n                },\n                body: [inspect(object)]\n            }\n        });\n    }});\n};\n\n/**\n */\nexports.ParseQuery = function (app) {\n    return function (request, response) {\n        request.query = QS.parse(URL.parse(request.url).query || \"\");\n        return app(request, response);\n    };\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/negotiate.js":"\nvar Q = require(\"q\");\nvar MimeParse = require(\"mimeparse\");\nvar Status = require(\"./status\");\n\nexports.negotiate = negotiate;\nfunction negotiate(request, types, header) {\n    var keys = Object.keys(types);\n    var accept = request.headers[header || \"accept\"] || \"*\";\n    var best = MimeParse.bestMatch(keys, accept);\n    return types[best];\n}\n\n/// branch on HTTP method\n/**\n * @param {Object * App} methods\n * @param {App} notAllowed (optional)\n * @returns {App}\n */\nexports.Method = function (methods, methodNotAllowed) {\n    var keys = Object.keys(methods);\n    if (!methodNotAllowed)\n        methodNotAllowed = Status.methodNotAllowed;\n    return function (request) {\n        var method = request.method;\n        if (Object.has(keys, method)) {\n            return Object.get(methods, method)(request);\n        } else {\n            return methodNotAllowed(request);\n        }\n    };\n};\n\nvar Negotiator = function (requestHeader, responseHeader, respond) {\n    return function (types, notAcceptable) {\n        var keys = Object.keys(types);\n        if (!notAcceptable)\n            notAcceptable = Status.notAcceptable;\n        return function (request) {\n            var accept = request.headers[requestHeader] || \"*\";\n            var type = MimeParse.bestMatch(keys, accept);\n            request.terms = request.terms || {};\n            request.terms[responseHeader] = type;\n            if (Object.has(keys, type)) {\n                return Q.when(types[type](request), function (response) {\n                    if (\n                        respond !== null &&\n                        response &&\n                        response.status === 200 &&\n                        response.headers\n                    ) {\n                        response.headers[responseHeader] = type;\n                    }\n                    return response;\n                });\n            } else {\n                return notAcceptable(request);\n            }\n        };\n    };\n};\n\n/// branch on HTTP content negotiation\n/**\n * Routes based on content negotiation, between the request's `accept`\n * header and the application's list of possible content types.\n *\n * @param {Object * App} types mapping content types to apps that can\n * handle them.\n * @param {App} notAcceptable\n * @returns {App}\n */\nexports.ContentType = Negotiator(\"accept\", \"content-type\");\nexports.Language = Negotiator(\"accept-language\", \"language\");\nexports.Charset = Negotiator(\"accept-charset\", \"charset\");\nexports.Encoding = Negotiator(\"accept-encoding\", \"encoding\");\n\nexports.Host = function (appForHost, notAcceptable) {\n    var table = Object.keys(appForHost).map(function (pattern) {\n        var parts = pattern.split(\":\");\n        return [\n            pattern,\n            parts[0] || \"*\",\n            parts[1] || \"*\",\n            appForHost[pattern]\n        ];\n    });\n    if (!notAcceptable) {\n        notAcceptable = Status.notAcceptable;\n    }\n    return function (request) {\n        // find first matching host for app\n        for (var index = 0; index < table.length; index++) {\n            var row = table[index]; // [hostname, port, app]\n            var pattern = row[0];\n            var hostname = row[1];\n            var port = row[2];\n            var app = row[3];\n            if (\n                (hostname === \"*\" || hostname === request.hostname) &&\n                (port === \"*\" || port === \"\" + request.port)\n            ) {\n                request.terms = request.terms || {};\n                request.terms.host = pattern;\n                return app(request);\n            }\n        }\n        return notAcceptable(request);\n    };\n};\n\n// Branch on a selector function based on the request\nexports.Select = function (select) {\n    return function (request) {\n        return Q.when(select(request), function (app) {\n            return app(request);\n        });\n    };\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/status.js":"\nvar Negotiation = require(\"./negotiate\");\nvar HtmlApps = require(\"./html\");\n\n/**\n * {Object * String} a mapping of HTTP status codes to\n * their standard descriptions.\n */\n// Every standard HTTP code mapped to the appropriate message.\n// Stolen from Rack which stole from Mongrel\nexports.statusCodes = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Large',\n    415: 'Unsupported Media Type',\n    416: 'Request Range Not Satisfiable',\n    417: 'Expectation Failed',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    507: 'Insufficient Storage'\n};\n\n/**\n * {Object * Number} a mapping from HTTP status descriptions\n * to HTTP status codes.\n */\nexports.statusMessages = {};\nfor (var code in exports.statusCodes)\n    exports.statusMessages[exports.statusCodes[code]] = +code;\n\n/**\n * Determines whether an HTTP response should have a\n * response body, based on its status code.\n * @param {Number} status\n * @returns whether the HTTP response for the given status\n * code has content.\n */\nexports.statusWithNoEntityBody = function (status) {\n    return (status >= 100 && status <= 199) ||\n        status == 204 || status == 304;\n};\n\n/**\n * @param {Number} status\n * @returns {Function(Request) :Response} a JSGI app that returns\n * a plain text response with the given status code.\n */\nexports.appForStatus = function (status) {\n    return function (request) {\n        return exports.responseForStatus(request, status, request.method + \" \" + request.path);\n    };\n};\n\n/**\n * @param {Number} status an HTTP status code\n * @param {String} message (optional) a message to include\n * in the response body.\n * @returns a JSGI HTTP response object with the given status\n * code and message as its body, if the status supports\n * a body.\n */\nexports.responseForStatus = function(request, status, addendum) {\n    if (exports.statusCodes[status] === undefined)\n        throw \"Unknown status code\";\n\n    var message = exports.statusCodes[status];\n\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    if (exports.statusWithNoEntityBody(status)) {\n        return {status: status, headers: {}};\n    } else {\n        var handlers = {};\n        handlers[\"text/plain\"] = exports.textResponseForStatus;\n        if (request.handleHtmlFragmentResponse) {\n            handlers[\"text/html\"] = exports.htmlResponseForStatus;\n        }\n        var responseForStatus = Negotiation.negotiate(request, handlers) || exports.textResponseForStatus;\n        return responseForStatus(request, status, message, addendum);\n    }\n};\n\nexports.textResponseForStatus = function (request, status, message, addendum) {\n    var content = message + \"\\n\";\n    if (addendum) {\n        content += addendum + \"\\n\";\n    }\n    var contentLength = content.length;\n    return {\n        status: status,\n        statusMessage: message,\n        headers: {\n            \"content-length\": contentLength\n        },\n        body: [content]\n    };\n};\n\nexports.htmlResponseForStatus = function (request, status, message, addendum) {\n    return {\n        status: status,\n        statusMessage: message,\n        headers: {},\n        htmlTitle: message,\n        htmlFragment: {\n            forEach: function (write) {\n                write(\"<h1>\" + HtmlApps.escapeHtml(message) + \"</h1>\\n\");\n                write(\"<p>Status: \" + status + \"</p>\\n\");\n                if (addendum) {\n                    write(\"<pre>\" + HtmlApps.escapeHtml(addendum) + \"</pre>\\n\");\n                }\n            }\n        }\n    }\n};\n\n/**\n * {App} an application that returns a 400 response.\n */\nexports.badRequest = exports.appForStatus(400);\n/**\n * {App} an application that returns a 404 response.\n */\nexports.notFound = exports.appForStatus(404);\n/**\n * {App} an application that returns a 405 response.\n */\nexports.methodNotAllowed = exports.appForStatus(405);\n/**\n * {App} an application that returns a 405 response.\n */\nexports.noLanguage =\nexports.notAcceptable = exports.appForStatus(406);\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/html.js":"\nvar Q = require(\"q\");\n// TODO negotiate text/html vs text/html+fragment (or other mime type)\n\n/**\n * @param {Request} request\n * @param {String} path\n * @param {String} contentType\n * @returns {Response}\n */\nexports.HandleHtmlFragmentResponses = function (app, handleHtmlFragmentResponse) {\n    handleHtmlFragmentResponse = handleHtmlFragmentResponse || exports.handleHtmlFragmentResponse;\n    return function (request) {\n        request.handleHtmlFragmentResponse = handleHtmlFragmentResponse;\n        return Q.fcall(app, request)\n        .then(function (response) {\n            if (response.htmlFragment) {\n                return Q.fcall(handleHtmlFragmentResponse, response);\n            } else {\n                return response;\n            }\n        });\n    };\n};\n\nexports.handleHtmlFragmentResponse = function (response) {\n    var htmlFragment = response.htmlFragment;\n    delete response.htmlFragment;\n    response.headers[\"content-type\"] = \"text/html; charset=utf-8\";\n    response.body = {\n        forEach: function (write) {\n            write(\"<!doctype html>\\n\");\n            write(\"<html>\\n\");\n            write(\"    <head>\\n\");\n            if (response.htmlTitle !== void 0) {\n                write(\"        <title>\" + escapeHtml(response.htmlTitle) + \"</title>\\n\");\n            }\n            write(\"    </head>\\n\");\n            write(\"    <body>\\n\");\n            htmlFragment.forEach(function (line) {\n                write(\"        \" + line);\n            });\n            write(\"    </body>\\n\");\n            write(\"</html>\\n\");\n        }\n    };\n    return response;\n};\n\nexports.escapeHtml = escapeHtml;\nfunction escapeHtml(text) {\n    return String(text)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n}\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/cookie.js":"\nvar Q = require(\"q\");\nvar Cookie = require(\"../http-cookie\");\nQ.longStackSupport = true;\n\nexports.CookieJar = function (app) {\n    var hostCookies = {}; // to {} of pathCookies to [] of cookies\n    return function (request) {\n\n        if (!request.headers.host) {\n            throw new Error(\"Requests must have a host header\");\n        }\n        var hosts = allHostsContaining(request.headers.host);\n\n        var now = new Date();\n\n        // delete expired cookies\n        for (var host in hostCookies) {\n            var pathCookies = hostCookies[host];\n            for (var path in pathCookies) {\n                var cookies = pathCookies[path];\n                for (var name in cookies) {\n                    var cookie = cookies[name];\n                    if (cookie.expires && cookie.expires > now) {\n                        delete cookie[name];\n                    }\n                }\n            }\n        }\n\n        // collect applicable cookies\n        var requestCookies = concat(\n            Object.keys(hostCookies)\n            .map(function (host) {\n                if (!hostContains(host, request.headers.host)) {\n                    return [];\n                }\n                var pathCookies = hostCookies[host];\n                return concat(\n                    Object.keys(pathCookies)\n                    .map(function (path) {\n                        if (!pathContains(path, request.path))\n                            return [];\n                        var cookies = pathCookies[path];\n                        return (\n                            Object.keys(cookies)\n                            .map(function (name) {\n                                return cookies[name];\n                            })\n                            .filter(function (cookie) {\n                                return cookie.secure ?\n                                    request.ssl :\n                                    true;\n                            })\n                        );\n                    })\n                )\n            })\n        );\n\n        if (requestCookies.length) {\n            request.headers[\"cookie\"] = (\n                requestCookies\n                .map(function (cookie) {\n                    return Cookie.stringify(\n                        cookie.key,\n                        cookie.value\n                    );\n                })\n                .join(\"; \")\n            );\n        }\n\n        return Q.when(app.apply(this, arguments), function (response) {\n            response.headers = response.headers || {};\n            if (response.headers[\"set-cookie\"]) {\n                var host = request.headers.host;\n                var hostParts = splitHost(host);\n                var hostname = hostParts[0];\n                var requestHost = ipRe.test(hostname) ? host : \".\" + host;\n                // normalize to array\n                if (!Array.isArray(response.headers[\"set-cookie\"])) {\n                    response.headers[\"set-cookie\"] = [response.headers[\"set-cookie\"]];\n                }\n                response.headers[\"set-cookie\"].forEach(function (cookie) {\n                    var date = response.headers[\"date\"] ?\n                        new Date(response.headers[\"date\"]) :\n                        new Date();\n                    cookie = Cookie.parse(cookie, date);\n                    // ignore illegal host\n                    if (cookie.host && !hostContains(requestHost, cookie.host))\n                        delete cookie.host;\n                    var host = requestHost || cookie.host;\n                    var path = cookie.path || \"/\";\n                    var pathCookies = hostCookies[host] = hostCookies[host] || {};\n                    var cookies = pathCookies[path] = pathCookies[path] || {};\n                    cookies[cookie.key] = cookie;\n                })\n                delete response.headers[\"set-cookie\"];\n            }\n\n            return response;\n        });\n\n    };\n};\n\nvar ipRe = /^\\d+\\.\\d+\\.\\d+\\.\\d+$/;\nvar portRe = /^(.*)(:\\d+)$/;\n\nfunction splitHost(host) {\n    var match = portRe.exec(host);\n    if (match) {\n        return [match[1], match[2]];\n    } else {\n        return [host, \"\"];\n    }\n}\n\nfunction allHostsContaining(host) {\n    var parts = splitHost(host);\n    var hostname = parts[0];\n    var port = parts[1];\n    if (ipRe.test(hostname)) {\n        return [hostname + port];\n    } if (hostname === \"localhost\") {\n        return [hostname + port];\n    } else {\n        var parts = hostname.split(\".\");\n        var hosts = [];\n        while (parts.length > 1) {\n            hosts.push(\".\" + parts.join(\".\") + port);\n            parts.shift();\n        }\n        return hosts;\n    }\n}\n\nfunction hostContains(containerHost, contentHost) {\n    var containerParts = splitHost(containerHost);\n    var containerHostname = containerParts[0];\n    var containerPort = containerParts[1];\n    var contentParts = splitHost(contentHost);\n    var contentHostname = contentParts[0];\n    var contentPort = contentParts[1];\n    if (containerPort !== contentPort) {\n        return false;\n    }\n    if (ipRe.test(containerHostname) || ipRe.test(contentHostname)) {\n        return containerHostname === contentHostname;\n    } else if (/^\\./.test(containerHostname)) {\n        return (\n            contentHostname.lastIndexOf(containerHostname) ===\n            contentHostname.length - containerHostname.length\n        ) || (\n            containerHostname.slice(1) === contentHostname\n        );\n    } else {\n        return containerHostname === contentHostname;\n    }\n};\n\nfunction pathContains(container, content) {\n    if (/^\\/$/.test(container)) {\n        return content.indexOf(container) === 0;\n    } else {\n        return (\n            content === container ||\n            content.indexOf(container + \"/\") === 0\n        );\n    }\n}\n\nfunction concat(arrays) {\n    return [].concat.apply([], arrays);\n}\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-cookie.js":"\n/**\n * Provides utilities for reading and writing HTTP cookies.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar QS = require(\"qs\");\n\n/**\n * @param {String} cookie\n * @returns {Object}\n */\nexports.parse = function (cookie, date) {\n    date = date || new Date();\n    var parsed = {};\n    var terms = cookie.split(/[;,]/g);\n    var keyValue = terms.shift().split(\"=\");\n    parsed.key = decodeURIComponent(keyValue[0]);\n    parsed.value = decodeURIComponent(keyValue[1]);\n    terms.forEach(function (term) {\n        var parts = term.split(\"=\").map(function (part) {\n            return part.trim();\n        });\n        var key = parts[0], value = parts[1];\n        if (/^domain$/i.test(key)) {\n            parsed.domain = value;\n        } else if (/^path$/i.test(key)) {\n            parsed.path = value;\n        } else if (/^expires$/i.test(key)) {\n            parsed.expires = new Date(\n                +new Date() + // actual now\n                (new Date(value) - date) // server offset\n            );\n        } else if (/^max-age$/i.test(key)) {\n            parsed.expires = new Date(\n                new Date().getTime() +\n                (value * 1000)\n            );\n        } else if (/^secure$/i.test(key)) {\n            parsed.secure = true;\n        } else if (/^httponly$/i.test(key)) {\n            parsed.httpOnly = true;\n        }\n    });\n    return parsed;\n};\n\n/**\n * @param {String} key\n * @param {String} value\n * @param {Object} options (optional)\n * @returns {String} a cookie string\n */\nexports.stringify = function (key, value, options) {\n    var cookie = (\n        encodeURIComponent(key) + \"=\" +\n        encodeURIComponent(value)\n    );\n    if (options) {\n        if (options.domain)\n            cookie += \"; Domain=\" + encodeURIComponent(options.domain);\n        if (options.path)\n            cookie += \"; Path=\" + encodeURIComponent(options.path);\n        if (options.expires)\n            cookie += \"; Expires=\" + options.expires.toGMTString();\n        if (options.secure)\n            cookie += \"; Secure\";\n        if (options.httpOnly)\n            cookie += \"; HttpOnly\";\n    }\n    return cookie;\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/decorators.js":"\nvar Q = require(\"q\");\nvar HTTP = require(\"../http\");\nvar RouteApps = require(\"./route\");\nvar StatusApps = require(\"./status\");\n\nexports.Normalize = function (app) {\n    return function (request, response) {\n        var request = HTTP.normalizeRequest(request);\n        return Q.when(app(request, response), function (response) {\n            return HTTP.normalizeResponse(response);\n        });\n    };\n};\n\nexports.Date = function (app, present) {\n    present = present || function () {\n        return new Date();\n    };\n    return RouteApps.Trap(app, function (response, request) {\n        response.headers[\"date\"] = \"\" + present();\n    });\n};\n\n/**\n * Decorates a JSGI application such that rejected response promises\n * get translated into `500` server error responses with no content.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Error = function (app, debug) {\n    return function (request, response) {\n        return Q.when(app(request, response), null, function (error) {\n            if (!debug)\n                error = undefined;\n            return StatusApps.responseForStatus(request, 500, error && error.stack || error);\n        });\n    };\n};\n\nexports.Debug = function (app) {\n    return exports.Error(app, true);\n};\n\n/**\n * Decorates a Q-JSGI application such that all requests and responses\n * are logged.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Log = function (app, log, stamp) {\n    log = log || console.log;\n    stamp = stamp || function (message) {\n        return new Date().toISOString() + \" \" + message;\n    };\n    return function (request, response) {\n        var remoteHost =\n            request.remoteHost + \":\" +\n            request.remotePort;\n        var requestLine =\n            request.method + \" \" +\n            request.path + \" \" +\n            \"HTTP/\" + request.version.join(\".\");\n        log(stamp(\n            remoteHost + \" \" +\n            \"-->     \" +\n            requestLine\n        ));\n        return Q.when(app(request, response), function (response) {\n            if (response) {\n                log(stamp(\n                    remoteHost + \" \" +\n                    \"<== \" +\n                    response.status + \" \" +\n                    requestLine + \" \" +\n                    (response.headers[\"content-length\"] || \"-\")\n                ));\n            } else {\n                log(stamp(\n                    remoteHost + \" \" +\n                    \"... \" +\n                    \"... \" +\n                    requestLine + \" (response undefined / presumed streaming)\"\n                ));\n            }\n            return response;\n        }, function (reason) {\n            log(stamp(\n                remoteHost + \" \" +\n                \"!!!     \" +\n                requestLine + \" \" +\n                (reason && reason.message || reason)\n            ));\n            return Q.reject(reason);\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all responses have an\n * X-Response-Time header with the time between the request and the\n * response in milliseconds, not including any time needed to stream\n * the body to the client.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Time = function (app) {\n    return function (request, response) {\n        var start = new Date();\n        return Q.when(app(request, response), function (response) {\n            var stop = new Date();\n            if (response && response.headers) {\n                response.headers[\"x-response-time\"] = \"\" + (stop - start);\n            }\n            return response;\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all responses have the\n * given additional headers.  These headers do not override the\n * application's given response headers.\n *\n * @param {Object} headers\n * @param {App} app decorated application.\n */\nexports.Headers = function (app, headers) {\n    return function (request, response) {\n        return Q.when(app(request, response), function (response) {\n            if (response && response.headers) {\n                Object.keys(headers).forEach(function (key) {\n                    if (!(key in response.headers)) {\n                        response.headers[key] = headers[key];\n                    }\n                });\n            }\n            return response;\n        });\n    };\n};\n\nvar farFuture =\n    1000 * // ms\n    60 * // s\n    60 * // m\n    24 * // h\n    365 * // d\n    10; // years\nexports.Permanent = function (app, future) {\n    future = future || function () {\n        return new Date(new Date().getTime() + farFuture);\n    };\n    app = RouteApps.Tap(app, function (request, response) {\n        request.permanent = future;\n    });\n    app = RouteApps.Trap(app, function (response, request) {\n        response.headers[\"expires\"] = \"\" + future();\n    });\n    return app;\n};\n\n/**\n * Wraps a Q-JSGI application in a sequence of decorators.\n * @param {Array * Decorator} decorators\n * @param {App} app\n * @returns {App}\n */\nexports.Decorators = function (decorators, app) {\n    decorators.reversed().forEach(function (Middleware) {\n        app = Middleware(app);\n    });\n    return app;\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/route.js":"\nvar Q = require(\"q\");\nvar StatusApps = require(\"./status\");\n\n/**\n * Makes a  Q-JSGI app that only responds when there is nothing left\n * on the path to route.  If the there is unprocessed data on the\n * path, the returned app either forwards to the `notFound` app or\n * returns a `404 Not Found` response.\n *\n * @param {App} app a Q-JSGI application to\n * respond to this end of the routing chain.\n * @param {App} notFound (optional) defaults\n * to the `notFound` app.\n * @returns {App}\n */\nexports.Cap = function (app, notFound) {\n    notFound = notFound || StatusApps.notFound;\n    return function (request, response) {\n        // TODO Distinguish these cases\n        if (request.pathInfo === \"\" || request.pathInfo === \"/\") {\n            return app(request, response);\n        } else {\n            return notFound(request, response);\n        }\n    };\n};\n\n/**\n * Wraps an app with a function that will observe incoming requests\n * before giving the app an opportunity to respond.  If the \"tap\"\n * function returns a response, it will be used in lieu of forwarding\n * the request to the wrapped app.\n */\nexports.Tap = function (app, tap) {\n    return function (request, response) {\n        var self = this, args = arguments;\n        return Q.when(tap.apply(this, arguments), function (response) {\n            if (response) {\n                return response;\n            } else {\n                return app.apply(self, args);\n            }\n        });\n    };\n};\n\n/**\n * Wraps an app with a \"trap\" function that intercepts and may\n * alter or replace the response of the wrapped application.\n */\nexports.Trap = function (app, trap) {\n    return function (request, response) {\n        return Q.when(app.apply(this, arguments), function (response) {\n            if (response) {\n                response.headers = response.headers || {};\n                return trap(response, request) || response;\n            }\n        });\n    };\n};\n\n/**\n * Makes a Q-JSGI app that branches requests based on the next\n * unprocessed path component.\n * @param {Object * App} paths a mapping from path components (single\n * file or directory names) to Q-JSGI applications for subsequent\n * routing.  The mapping may be a plain JavaScript `Object` record,\n * which must own the mapping properties, or an object that has\n * `has(key)` and `get(key)` methods in its prototype chain.\n * @param {App} notFound a Q-JSGI application\n * that handles requests for which the next file name does not exist\n * in paths.\n * @returns {App}\n */\nexports.Branch = function (paths, notFound) {\n    if (!paths)\n        paths = {};\n    if (!notFound)\n        notFound = StatusApps.notFound;\n    return function (request, response) {\n        if (!/^\\//.test(request.pathInfo)) {\n            return notFound(request, response);\n        }\n        var path = request.pathInfo.slice(1);\n        var parts = path.split(\"/\");\n        var part = decodeURIComponent(parts.shift());\n        if (Object.has(paths, part)) {\n            request.scriptName = request.scriptName + part + \"/\";\n            request.pathInfo = path.slice(part.length);\n            return Object.get(paths, part)(request, response);\n        }\n        return notFound(request, response);\n    };\n};\n\n/**\n * Returns the response of the first application that returns a\n * non-404 response status.\n *\n * @param {Array * App} apps a cascade of applications to try\n * successively until one of them returns a non-404 status.\n * @returns {App}\n */\nexports.FirstFound = function (cascade) {\n    return function (request, response) {\n        var i = 0, ii = cascade.length;\n        function next() {\n            var response = cascade[i++](request, response);\n            if (i < ii) {\n                return Q.when(response, function (response) {\n                    if (response.status === 404) {\n                        return next();\n                    } else {\n                        return response;\n                    }\n                });\n            } else {\n                return response;\n            }\n        }\n        return next();\n    };\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/json.js":"var Q = require(\"q\");\nvar Content = require(\"./content\");\nvar Status = require(\"./status\");\n\nexports.HandleJsonResponses = function (app, reviver, tab) {\n    return function (request) {\n        request.handleJsonResponse = exports.handleJsonResponse;\n        return Q.fcall(app, request)\n        .then(function (response) {\n            if (response.data !== void 0) {\n                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);\n            } else {\n                return response;\n            }\n        });\n    };\n};\n\nexports.handleJsonResponse = function (response, revivier, tab) {\n    response.headers[\"content-type\"] = \"application/json\";\n    response.body = {\n        forEach: function (write) {\n            write(JSON.stringify(response.data, revivier, tab));\n        }\n    };\n    return response;\n};\n\n/**\n * Wraps a Q-JSGI application such that the child application may\n * simply return an object, which will in turn be serialized into a\n * Q-JSGI response.\n *\n * @param {Function(Request):Object} app an application that accepts a\n * request and returns a JSON serializable object.\n * @returns {App}\n */\nexports.Json = function (app, reviver, tabs) {\n    return function (request, response) {\n        return Q.when(app(request, response), function (object) {\n            return exports.json(object, reviver, tabs);\n        });\n    };\n};\n\n/**\n * @param {Object} content data to serialize as JSON\n * @param {Function} reviver\n * @param {Number|String} tabs\n * @returns {Response}\n */\nexports.json = function (content, reviver, tabs) {\n    try {\n        var json = JSON.stringify(content, reviver, tabs);\n    } catch (exception) {\n        return Q.reject(exception);\n    }\n    return Content.ok([json], \"application/json\");\n};\n\n/**\n * @param {Function(Request, Object):Response} app\n * @param {App} badRequest\n * @returns {App}\n */\nexports.JsonRequest = function (app, badRequest) {\n    if (!badRequest)\n        badRequest = Status.badRequest;\n    return Content.ContentRequest(function (content, request, response) {\n        try {\n            var object = JSON.parse(content);\n        } catch (error) {\n            return badRequest(request, error);\n        }\n        return app(object, request, response);\n    });\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/proxy.js":"\nvar HTTP = require(\"../http\");\nvar URL = require(\"url2\");\nvar Q = require(\"q\");\n\nexports.Proxy = function (app) {\n    if (typeof app === \"string\") {\n        var location = app;\n        app = function (request) {\n            request.url = location;\n            return request;\n        };\n    }\n    return function (request, response) {\n        return Q.when(app.apply(this, arguments), function (request) {\n            return HTTP.request(request);\n        });\n    };\n};\n\nexports.ProxyTree = function (url) {\n    return exports.Proxy(function (request) {\n        request.url = URL.resolve(url, request.pathInfo.replace(/^\\//, \"\"));\n        return request;\n    });\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/redirect.js":"\nvar Q = require(\"q\");\nvar URL = require(\"url2\");\nvar Http = require(\"../http\");\nvar Negotiation = require(\"./negotiate\");\nvar HtmlApps = require(\"./html\");\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `301`\n * @returns {App}\n */\nexports.PermanentRedirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.permanentRedirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `301`\n * @returns {App}\n */\nexports.PermanentRedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.permanentRedirect(request, location, status, true);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.TemporaryRedirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.temporaryRedirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.TemporaryRedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.temporaryRedirect(request, location, status, true);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.Redirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.redirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.RedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.redirect(request, location, status, true);\n    };\n};\n\nexports.permanentRedirect = function (request, location, status) {\n    return exports.redirect(request, location, status || 301);\n};\n\nexports.permanentRedirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status || 301, true);\n};\n\nexports.temporaryRedirect = function (request, location, status) {\n    return exports.redirect(request, location, status || 307);\n};\n\nexports.temporaryRedirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status || 307, true);\n};\n\nexports.redirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status, true);\n};\n\n/**\n * @param {String} location\n * @param {Number} status (optional) default is `301`\n * @returns {Response}\n */\nexports.redirect = function (request, location, status, tree) {\n\n    // request.permanent gets set by Permanent middleware\n    status = status || (request.permanent ? 301 : 307);\n\n    // ascertain that the location is absolute, per spec\n    location = URL.resolve(request.url, location);\n\n    // redirect into a subtree with the remaining unrouted\n    // portion of the path, if so configured\n    if (tree) {\n        location = URL.resolve(\n            location,\n            request.pathInfo.replace(/^\\//, \"\")\n        );\n    }\n\n    var handlers = {};\n    handlers[\"text/plain\"] = exports.redirectText;\n    if (request.handleHtmlFragmentResponse) {\n        handlers[\"text/html\"] = exports.redirectHtml;\n    }\n    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;\n    return handler(request, location, status);\n\n};\n\nexports.redirectText = function (request, location, status) {\n    var content = (\n        (request.permanent ? \"Permanent redirect\\n\" : \"Temporary redirect\\n\") +\n        \"See: \" + location + \"\\n\"\n    );\n    var contentLength = content.length;\n    return {\n        status: status,\n        headers: {\n            location: location,\n            \"content-type\": \"text/plain\"\n        },\n        body: [content]\n    };\n};\n\nexports.redirectHtml = function (request, location, status) {\n    var title = request.permanent ? \"Permanent redirect\" : \"Temporary redirect\";\n    return {\n        status: status,\n        headers: {\n            location: location,\n            \"content-type\": \"text/html\"\n        },\n        htmlTitle: title,\n        htmlFragment: {\n            forEach: function (write) {\n                write(\"<h1>\" + HtmlApps.escapeHtml(title) + \"</h1>\\n\");\n                write(\n                    \"<p>See: <a href=\\\"\" + HtmlApps.escapeHtml(location) + \"\\\">\" +\n                    HtmlApps.escapeHtml(location) +\n                    \"</a></p>\\n\"\n                );\n            }\n        }\n    };\n};\n\nexports.RedirectTrap = function (app, maxRedirects) {\n    maxRedirects = maxRedirects || 20;\n    return function (request, response) {\n        var remaining = maxRedirects;\n        var deferred = Q.defer();\n        var self = this;\n        var args = arguments;\n\n        request = Http.normalizeRequest(request);\n\n        // try redirect loop\n        function next() {\n            Q.fcall(function () {\n                return app(request, response);\n            })\n            .then(function (response) {\n                if (exports.isRedirect(response)) {\n                    if (remaining--) {\n                        request.url = response.headers.location;\n                        next();\n                    } else {\n                        throw new Error(\"Maximum redirects.\");\n                    }\n                } else {\n                    deferred.resolve(response);\n                }\n            })\n            .fail(deferred.reject)\n        }\n        next();\n\n        return deferred.promise;\n    };\n};\n\nexports.isRedirect = function (response) {\n    return isRedirect[response.status] || false;\n};\n\nvar isRedirect = {\n    301: true,\n    302: true,\n    303: true,\n    307: true\n};\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps.js":"\n/**\n * Provides tools for making, routing, adapting, and decorating\n * Q-JSGI web applications.\n *\n * Duck Types\n * ----------\n *\n * A Q-JSGI _app_ is a function that accepts a request and returns a\n * response.  The response may be promised.\n *\n * A Q-JSGI _request_ is an object or a promise for an object that has\n * the following properties:\n *\n * * `method` is the HTTP request method as a string.\n * * `path` is a string, guaranteed to start with `\"/\"`.\n * * `headers` is an object mapping lower-case HTTP headers to\n *   their corresponding values as strings.\n * * `body` is a Q-JSGI content body.\n *\n * A Q-JSGI _response_ is an object or a promise for an object that\n * has the following properties:\n *\n * * `status` is the HTTP response status code as a number.\n * * `headers` is an object mapping lower-case HTTP headers to their\n *   corresponding values as strings.\n * * `body` is a Q-JSGI content body.\n *\n * A Q-JSGI response and request content _body_ can be as simple as an\n * array of strings.  It can be a promise.  In general, it must be an\n * object that has a `forEach` method.  The `forEach` method accepts a\n * `write` function.  It goes without saying that `forEach` returns\n * `undefined`, but it can return a promise for `undefined` that will\n * resolve when it has made all of its `write` calls and the request\n * or response can be closed, re-used, or kept alive..  The `forEach`\n * function may call `write` with a `String` any number of times.  The\n * `String` may be promised.\n *\n * @module\n */\n\nrequire(\"collections/shim\");\nvar Q = require(\"q\");\nvar HTTP = require(\"./http\");\nvar FS = require(\"./fs\");\nvar URL = require(\"url2\");\nvar inspect = require(\"util\").inspect;\n\nexports.Chain = require(\"./http-apps/chain\");\n\nvar RouteApps = require(\"./http-apps/route\");\nexports.Cap = RouteApps.Cap;\nexports.Tap = RouteApps.Tap;\nexports.Trap = RouteApps.Trap;\nexports.Branch = RouteApps.Branch;\n\nvar ContentApps = require(\"./http-apps/content\");\nexports.Content = ContentApps.Content;\nexports.content = ContentApps.content;\nexports.ok = ContentApps.ok;\nexports.ContentRequest = ContentApps.ContentRequest;\nexports.Inspect = ContentApps.Inspect;\nexports.ParseQuery = ContentApps.ParseQuery;\n\nvar FsApps = require(\"./http-apps/fs\");\nexports.File = FsApps.File;\nexports.FileTree = FsApps.FileTree;\nexports.file = FsApps.file;\nexports.directory = FsApps.directory;\nexports.etag = FsApps.etag;\n\nexports.ListDirectories = FsApps.ListDirectories;\nexports.listDirectory = FsApps.listDirectory;\nexports.listDirectoryHtmlFragment = FsApps.listDirectoryHtmlFragment;\nexports.listDirectoryText = FsApps.listDirectoryText;\nexports.listDirectoryMarkdown = FsApps.listDirectoryMarkdown;\nexports.listDirectoryJson = FsApps.listDirectoryJson;\nexports.listDirectoryData = FsApps.listDirectoryData;\nexports.DirectoryIndex = FsApps.DirectoryIndex;\n\nvar HtmlApps = require(\"./http-apps/html\");\nexports.HandleHtmlFragmentResponses = HtmlApps.HandleHtmlFragmentResponses;\nexports.handleHtmlFragmentResponse = HtmlApps.handleHtmlFragmentResponse;\nexports.escapeHtml = HtmlApps.escapeHtml;\n\nvar JsonApps = require(\"./http-apps/json\");\nexports.HandleJsonResponses = JsonApps.HandleJsonResponses;\nexports.handleJsonResponse = JsonApps.handleJsonResponse;\nexports.Json = JsonApps.Json;\nexports.json = JsonApps.json;\nexports.JsonRequest = JsonApps.JsonRequest;\n\nvar RedirectApps = require(\"./http-apps/redirect\");\nexports.PermanentRedirect = RedirectApps.PermanentRedirect;\nexports.PermanentRedirectTree = RedirectApps.PermanentRedirectTree;\nexports.TemporaryRedirect = RedirectApps.TemporaryRedirect;\nexports.TemporaryRedirectTree = RedirectApps.TemporaryRedirectTree;\nexports.Redirect = RedirectApps.Redirect;\nexports.RedirectTree = RedirectApps.RedirectTree;\nexports.permanentRedirect = RedirectApps.permanentRedirect;\nexports.permanentRedirectTree = RedirectApps.permanentRedirectTree;\nexports.temporaryRedirect = RedirectApps.temporaryRedirect;\nexports.temporaryRedirectTree = RedirectApps.temporaryRedirectTree;\nexports.redirectTree = RedirectApps.redirectTree;\nexports.redirect = RedirectApps.redirect;\nexports.redirectText = RedirectApps.redirectText;\nexports.redirectHtml = RedirectApps.redirectHtml;\nexports.RedirectTrap = RedirectApps.RedirectTrap;\nexports.isRedirect = RedirectApps.isRedirect;\n\nvar ProxyApps = require(\"./http-apps/proxy\");\nexports.Proxy = ProxyApps.Proxy;\nexports.ProxyTree = ProxyApps.ProxyTree;\n\nvar NegotiationApps = require(\"./http-apps/negotiate\");\nexports.negotiate = NegotiationApps.negotiate;\nexports.Method = NegotiationApps.Method;\nexports.ContentType = NegotiationApps.ContentType;\nexports.Language = NegotiationApps.Language;\nexports.Charset = NegotiationApps.Charset;\nexports.Encoding = NegotiationApps.Encoding;\nexports.Host = NegotiationApps.Host;\nexports.Select = NegotiationApps.Select;\n\nvar StatusApps = require(\"./http-apps/status\");\nexports.statusCodes = StatusApps.statusCodes;\nexports.statusMessages = StatusApps.statusMessages;\nexports.statusWithNoEntityBody = StatusApps.statusWithNoEntityBody;\nexports.appForStatus = StatusApps.appForStatus;\nexports.responseForStatus = StatusApps.responseForStatus;\nexports.textResponseForStatus = StatusApps.textResponseForStatus;\nexports.htmlResponseForStatus = StatusApps.htmlResponseForStatus;\nexports.badRequest = StatusApps.badRequest;\nexports.notFound = StatusApps.notFound;\nexports.methodNotAllowed = StatusApps.methodNotAllowed;\nexports.noLanguage = StatusApps.noLanguage;\nexports.notAcceptable = StatusApps.notAcceptable;\n\nvar DecoratorApps = require(\"./http-apps/decorators\");\nexports.Normalize = DecoratorApps.Normalize;\nexports.Date = DecoratorApps.Date;\nexports.Error = DecoratorApps.Error;\nexports.Debug = DecoratorApps.Debug;\nexports.Log = DecoratorApps.Log;\nexports.Time = DecoratorApps.Time;\nexports.Headers = DecoratorApps.Headers;\nexports.Permanent = DecoratorApps.Permanent;\nexports.Decorators = DecoratorApps.Decorators;\n\nvar CookieApps = require(\"./http-apps/cookie\");\nexports.CookieJar = CookieApps.CookieJar;\n\n","/home/travis/build/npmtest/node-npmtest-q-io/node_modules/q-io/http-apps/fs.js":"\nvar Q = require(\"q\");\nvar URL = require(\"url2\");\nvar MimeTypes = require(\"mime\");\nvar FS = require(\"../fs\");\nvar StatusApps = require(\"./status\");\nvar RedirectApps = require(\"./redirect\");\nvar Negotiation = require(\"./negotiate\");\nvar HtmlApps = require(\"./html\");\nvar Deprecate = require(\"../deprecate\");\n\n/**\n * @param {String} path\n * @param {String} contentType\n * @returns {App}\n */\nexports.File = function (path, contentType) {\n    return function (request, response) {\n        return exports.file(request, String(path), contentType);\n    };\n};\n\n/**\n * @param {String} path\n * @param {{\n       notFound,\n       file,\n       directory,\n       contentType,\n       redirectSymbolicLinks:Boolean,\n       redirect:Function(location),\n       permanent:Boolean\n * }} options\n * @returns {App}\n */\nexports.FileTree = function (root, options) {\n    if (!options)\n        options = {};\n    options.notFound = options.notFound || StatusApps.notFound;\n    options.file = options.file || exports.file;\n    options.directory = options.directory || exports.directory;\n    options.fs = options.fs || FS;\n    var fs = options.fs;\n    root = fs.canonical(root);\n    return function (request, response) {\n        var location = URL.parse(request.url);\n        request.fs = fs;\n        var redirect = options.redirect || (\n            request.permanent || options.permanent ?\n            RedirectApps.permanentRedirect :\n            RedirectApps.temporaryRedirect\n        );\n        return Q.when(root, function (root) {\n            var path = fs.join(root, request.pathInfo.slice(1));\n            return Q.when(fs.canonical(path), function (canonical) {\n                //TODO remove for 2.0.0\n                if (options.followInsecureSymlinks) {\n                    Deprecate.deprecationWarning(\"followInsecureSymlinks\", \"followInsecureSymbolicLinks\");\n                    options.followInsecureSymbolicLinks = true;\n                }\n                if (!fs.contains(root, canonical) && !options.followInsecureSymbolicLinks)\n                    return options.notFound(request, response);\n                if (path !== canonical && options.redirectSymbolicLinks)\n                    return redirect(request, fs.relativeFromFile(path, canonical));\n                // TODO: relativeFromFile should be designed for URLs, not generalized paths.\n                // HTTP.relative(pathToDirectoryLocation(path), pathToFile/DirectoryLocation(canonical))\n                return Q.when(fs.stat(canonical), function (stat) {\n                    if (stat.isFile()) {\n                        return options.file(request, canonical, options.contentType, fs);\n                    } else if (stat.isDirectory()) {\n                        return options.directory(request, canonical, options.contentType, fs);\n                    } else {\n                        return options.notFound(request, response);\n                    }\n                });\n            }, function (reason) {\n                return options.notFound(request, response);\n            });\n        });\n    };\n};\n\nexports.file = function (request, path, contentType, fs) {\n    fs = fs || FS;\n    // TODO last-modified header\n    contentType = contentType || MimeTypes.lookup(path);\n    return Q.when(fs.stat(path), function (stat) {\n        var etag = exports.etag(stat);\n        var options = {\n            flags: \"rb\"\n        };\n        var range;\n        var status = 200;\n        var headers = {\n            \"content-type\": contentType,\n            etag: etag\n        };\n\n        // Partial range requests\n        if (\"range\" in request.headers) {\n            // Invalid cache\n            if (\n                \"if-range\" in request.headers &&\n                etag != request.headers[\"if-range\"]\n            ) {\n                // Normal 200 for entire, altered content\n            } else {\n                // Truncate to the first requested continuous range\n                range = interpretFirstRange(request.headers[\"range\"], stat.size);\n                // Like Apache, ignore the range header if it is invalid\n                if (range) {\n                    if (range.end > stat.size) {\n                        range.end = stat.size;\n                    }\n                    if (range.end <= range.begin) {\n                        return StatusApps.responseForStatus(request, 416); // not satisfiable\n                    }\n                    status = 206; // partial content\n                    headers[\"content-range\"] = (\n                        \"bytes \" +\n                        range.begin + \"-\" + (range.end - 1) +\n                        \"/\" + stat.size\n                    );\n                    headers[\"content-length\"] = \"\" + (range.end - range.begin);\n                    options.begin = range.begin;\n                    options.end = range.end;\n                } else {\n                    return StatusApps.responseForStatus(request, 416); // not satisfiable\n                }\n            }\n        // Full requests\n        } else {\n            // Cached\n            // We do not use date-based caching\n            // TODO consider if-match?\n            if (etag == request.headers[\"if-none-match\"])\n                return StatusApps.responseForStatus(request, 304);\n            headers[\"content-length\"] = \"\" + stat.size;\n        }\n\n        // TODO sendfile\n        return {\n            status: status,\n            headers: headers,\n            body: fs.open(path, options),\n            file: path,\n            range: range\n        };\n    });\n};\n\nvar rangesExpression = /^\\s*bytes\\s*=\\s*(\\d*\\s*-\\s*\\d*\\s*(?:,\\s*\\d*\\s*-\\s*\\d*\\s*)*)$/;\nvar rangeExpression = /^\\s*(\\d*)\\s*-\\s*(\\d*)\\s*$/;\n\nvar interpretRange = function (text, size) {\n    var match = rangeExpression.exec(text);\n    if (!match)\n        return;\n    if (match[1] == \"\" && match[2] == \"\")\n        return;\n    var begin, end;\n    if (match[1] == \"\") {\n        begin = 0;\n        end = +match[2] + 1;\n    } else if (match[2] == \"\") {\n        begin = +match[1];\n        end = size;\n    } else {\n        begin = +match[1];\n        end = +match[2] + 1;\n    }\n    return {\n        begin: begin,\n        end: end\n    };\n};\n\nvar interpretFirstRange = exports.interpretFirstRange = function (text, size) {\n    var match = rangesExpression.exec(text);\n    if (!match)\n        return;\n    var texts = match[1].split(/\\s*,\\s*/);\n    var range = interpretRange(texts[0], size);\n    for (var i = 0, ii = texts.length; i < ii; i++) {\n        var next = interpretRange(texts[i], size);\n        if (next.begin <= range.end) {\n            range.end = next.end;\n        } else {\n            return; // Can't satisfy non-contiguous ranges TODO\n        }\n    }\n    return range;\n};\n\n/**\n * @param {Stat}\n * @returns {String}\n */\nexports.etag = function (stat) {\n    return [\n        stat.node.ino,\n        stat.size,\n        stat.lastModified().getTime()\n    ].join(\"-\");\n};\n\n/**\n * @param {Request} request\n * @param {String} path\n * @param {Response}\n */\nexports.directory = function (request, path) {\n    var response = StatusApps.notFound(request);\n    response.directory = path;\n    return response;\n};\n\nexports.ListDirectories = function (app, listDirectory) {\n    listDirectory = listDirectory || exports.listDirectory;\n    return function (request) {\n        if (request.directoryIndex) {\n            throw new Error(\"DirectoryIndex must be used after ListDirectories\");\n        }\n        request.listDirectories = true;\n        return Q.fcall(app, request)\n        .then(function (response) {\n            if (response.directory !== void 0) {\n                return listDirectory(request, response);\n            } else {\n                return response;\n            }\n        });\n    };\n};\n\nexports.listDirectory = function (request, response) {\n    // TODO advisory to have JSON or HTML fragment handler.\n    request.location = URL.parse(request.path);\n    if (request.location.file) {\n        return RedirectApps.redirect(request, request.location.file + \"/\");\n    }\n    var handlers = {};\n    handlers[\"text/plain\"] = exports.listDirectoryText;\n    handlers[\"text/markdown\"] = exports.listDirectoryMarkdown;\n    if (request.handleHtmlFragmentResponse) {\n        handlers[\"text/html\"] = exports.listDirectoryHtmlFragment;\n    }\n    if (request.handleJsonResponse) {\n        handlers[\"application/json\"] = exports.listDirectoryJson;\n    }\n    var handleResponse = Negotiation.negotiate(request, handlers) || function () {\n        return response;\n    };\n    return handleResponse(request, response);\n};\n\nexports.listDirectoryHtmlFragment = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {\n                \"content-type\": \"text/html\"\n            },\n            htmlTitle: \"Directory Index\",\n            htmlFragment: {\n                forEach: function (write) {\n                    write(\"<ul class=\\\"directory-index\\\">\\n\");\n                    Object.keys(data).sort().forEach(function (name) {\n                        var stat = data[name];\n                        var suffix = \"\";\n                        if (stat.type === \"directory\") {\n                            suffix = \"/\";\n                        }\n                        write(\"    <li class=\\\"entry \" + stat.type + \"\\\"><a href=\\\"\" + HtmlApps.escapeHtml(name + suffix) + \"\\\">\" + HtmlApps.escapeHtml(name + suffix) + \"</a></li>\\n\");\n                    });\n                    write(\"</ul>\\n\");\n                }\n            }\n        };\n    });\n};\n\nexports.listDirectoryText = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {\n                \"content-type\": \"text/plain\"\n            },\n            body: {\n                forEach: function (write) {\n                    Object.keys(data).sort().forEach(function (name) {\n                        var stat = data[name];\n                        var suffix = \"\";\n                        if (stat.type === \"directory\") {\n                            suffix = \"/\";\n                        }\n                        write(name + suffix + \"\\n\");\n                    });\n                }\n            }\n        };\n    });\n};\n\nexports.listDirectoryMarkdown = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {\n                \"content-type\": \"text/plain\"\n            },\n            body: {\n                forEach: function (write) {\n                    write(\"\\n# Directory Index\\n\\n\");\n                    Object.keys(data).forEach(function (name) {\n                        var stat = data[name];\n                        var suffix = \"\";\n                        if (stat.type === \"directory\") {\n                            suffix = \"/\";\n                        }\n                        write(\"-   \" + name + suffix + \"\\n\");\n                    });\n                    write(\"\\n\");\n                }\n            }\n        };\n    });\n};\n\nexports.listDirectoryJson = function (request, response) {\n    return exports.listDirectoryData(request, response)\n    .then(function (data) {\n        return {\n            status: 200,\n            headers: {},\n            data: data\n        };\n    });\n};\n\nexports.listDirectoryData = function (request, response) {\n    if (!request.fs) {\n        throw new Error(\"Can't list a directory without a designated file system\");\n    }\n    var fs = request.fs;\n    return Q.invoke(fs, \"list\", response.directory)\n    .then(function (list) {\n        list.sort();\n        return list.map(function (name) {\n            return Q.invoke(fs, \"stat\", fs.join(response.directory, name))\n            .then(function (stat) {\n                if (stat.isDirectory()) {\n                    return {name: name, stat: {\n                        type: \"directory\"\n                    }};\n                } else if (stat.isFile()) {\n                    return {name: name, stat: {\n                        type: \"file\"\n                    }};\n                }\n            }, function () {\n                // ignore unstatable entries\n            });\n        })\n    })\n    .all()\n    .then(function (stats) {\n        var data = {};\n        stats.forEach(function (entry) {\n            if (entry) {\n                data[entry.name] = entry.stat;\n            }\n        });\n        return data;\n    });\n};\n\nexports.DirectoryIndex = function (app, indexFile) {\n    indexFile = indexFile || \"index.html\";\n    return function (request) {\n        request.directoryIndex = true;\n        request.location = URL.parse(request.path);\n        // redirect index.html to containing directory\n        // TODO worry about whether this file actually exists\n        if (request.location.file === indexFile) {\n            return RedirectApps.redirect(request, \".\");\n        } else {\n            return Q.fcall(app, request)\n            .then(function (response) {\n                if (response.directory !== void 0) {\n                    if (request.location.file) {\n                        return RedirectApps.redirect(request, request.location.file + \"/\");\n                    } else {\n                        var index = request.fs.join(response.directory, indexFile);\n                        return Q.invoke(request.fs, \"isFile\", index)\n                        .then(function (isFile) {\n                            if (isFile) {\n                                request.url = URL.resolve(request.url, indexFile);\n                                request.pathInfo += indexFile;\n                                return app(request);\n                            } else {\n                                return response;\n                            }\n                        });\n                    }\n                } else {\n                    return response;\n                }\n            });\n        }\n    };\n};\n\n"}